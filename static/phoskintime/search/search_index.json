{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PhosKinTime Documentation","text":"<p>Welcome to the official documentation for PhosKinTime, an ODE-based modeling toolkit for phosphorylation kinetics and transcriptional time-series analysis. This index page provides an overview of each package and submodule in the project.</p>"},{"location":"#overview","title":"Overview","text":"<p>PhosKinTime integrates:</p> <ul> <li>Parameter estimation (normal and sequential modes)</li> <li>Mechanistic ODE models (distributive, successive, random)</li> <li>Steady-state computation</li> <li>Morris sensitivity analysis</li> <li>Static and interactive visualization</li> <li>Modular design for extensibility</li> </ul> <p>PhosKinTime uses ordinary differential equations (ODEs) to model phosphorylation kinetics and supports multiple mechanistic hypotheses, including: - Distributive Model: Phosphorylation events occur independently. - Successive Model: Phosphorylation events occur sequentially. - Random Model: Phosphorylation events occur in a random manner.</p> <p>The package is designed with modularity in mind. It consists of several key components: - Configuration: Centralized settings (paths, parameter bounds, logging, etc.) are defined in the config module. - Models: Different ODE models (distributive, successive, random) are implemented to simulate phosphorylation. - Parameter Estimation: Multiple routines (sequential and normal estimation) estimate kinetic parameters from experimental data. - Sensitivity Analysis: Morris sensitivity analysis is used to evaluate the influence of each parameter on the model output. - Steady-State Calculation: Functions compute steady-state initial conditions for ODE simulation. - Utilities: Helper functions support file handling, data formatting, report generation, and more. - Visualization: A comprehensive plotting module generates static and interactive plots to visualize model fits, parameter profiles, PCA, t-SNE, and sensitivity indices. - Exporting: The package can export results to Excel and generate HTML reports for easy sharing and documentation.  - CLI Interface: A command-line interface allows users to run the package without needing to modify the code directly.  - Documentation: The package includes extensive documentation to help users understand the functionality and usage of each module. - Testing: The package includes unit tests to ensure the reliability and correctness of the implemented algorithms. - Logging: A logging system is integrated to track the execution flow and capture important events during the analysis. - Error Handling: The package includes error handling mechanisms to manage exceptions and provide informative error messages. - Cross-Platform Compatibility: The package is designed to work on various operating systems, including Windows, macOS, and Linux. - Version Control: The package is version-controlled using Git, allowing users to track changes and collaborate effectively. - Continuous Integration: The package is set up with continuous integration (CI) tools to automate testing and ensure code quality. - Documentation Generation: The package uses tools like Sphinx to generate documentation from docstrings, making it easy to maintain and update the documentation as the code evolves. - Code Quality: The package follows best practices for code quality, including PEP 8 style guidelines, type hints, and docstrings for functions and classes.</p>"},{"location":"#core-packages","title":"Core Packages","text":""},{"location":"#bin","title":"bin/","text":"<p>Entry point for the pipeline. Contains <code>main.py</code>, which orchestrates configuration, data loading, parameter estimation, ODE simulation, visualization, and report generation.</p>"},{"location":"#config","title":"config/","text":"<p>Holds global constants, CLI parsing, and logging setup:</p> <ul> <li><code>constants.py</code>: model settings, time points, directories, scoring weights</li> <li><code>config.py</code>: argument parsing and configuration extraction</li> <li><code>logconf.py</code>: colored console and rotating file logging</li> <li><code>helpers/</code>: utilities for parameter names, state labels, bounds, and clickable paths</li> </ul>"},{"location":"#models","title":"models/","text":"<p>Implements ODE systems for different phosphorylation hypotheses:</p> <ul> <li><code>distmod.py</code>: distributive model</li> <li><code>succmod.py</code>: successive model</li> <li><code>randmod.py</code>: random model with JIT optimization</li> <li><code>weights.py</code>: weighting schemes for parameter estimation</li> </ul>"},{"location":"#paramest","title":"paramest/","text":"<p>Parameter estimation routines:</p> <ul> <li><code>normest.py</code>: global fit across all time points</li> <li><code>toggle.py</code>: selects estimation mode</li> <li><code>core.py</code>: integrates estimation, ODE solve, error metrics, and plotting</li> </ul>"},{"location":"#steady","title":"steady/","text":"<p>Computes steady-state initial conditions for each model:</p> <ul> <li><code>initdist.py</code>, <code>initsucc.py</code>, <code>initrand.py</code></li> </ul>"},{"location":"#sensitivity","title":"sensitivity/","text":"<p>Morris sensitivity analysis:</p> <ul> <li><code>analysis.py</code>: defines problem, sampling, analysis, and sensitivity plots</li> </ul>"},{"location":"#plotting","title":"plotting/","text":"<p>Visualization tools:</p> <ul> <li><code>Plotter</code> class with methods for parallel coordinates, PCA, t-SNE, parameter bar and series plots, model fit, GoF diagnostics, Kullback\u2013Leibler divergence, clusters, and heatmaps</li> </ul>"},{"location":"#utils","title":"utils/","text":"<p>Helper functions:</p> <ul> <li><code>display.py</code>: file and directory management, data loading, result saving, report generation</li> <li><code>tables.py</code>: table creation and export (LaTeX and CSV)</li> </ul>"},{"location":"#optimization-framework-kinopt","title":"Optimization Framework (kinopt)","text":"<p>The kinopt package provides advanced optimization and post-processing:</p>"},{"location":"#kinoptevol","title":"kinopt/evol","text":"<p>Global evolutionary optimization using pymoo (DE, NSGA-II):</p> <ul> <li>Problem formulation, data construction, exporter for Excel and plots</li> </ul>"},{"location":"#kinoptlocal","title":"kinopt/local","text":"<p>Local constrained optimization using SciPy solvers (SLSQP, TRUST-CONSTR) with Numba-accelerated objectives</p>"},{"location":"#kinoptoptimality","title":"kinopt/optimality","text":"<p>Post-optimization analysis: feasibility checks, sensitivity reporting, LaTeX table generation, diagnostic plots</p>"},{"location":"#kinoptpowell","title":"kinopt/powell","text":"<p>Julia-based Powell optimization bridge: runs <code>powell.jl</code>, configures threads, integrates results into post-processing</p>"},{"location":"#kinoptfitanalysis","title":"kinopt/fitanalysis","text":"<p>Additional fit-evaluation utilities for residual and performance analysis</p>"},{"location":"#optimization-framework-tfopt","title":"Optimization Framework (tfopt)","text":""},{"location":"#originally-implemented-by-julius-normann","title":"Originally implemented by Julius Normann.","text":""},{"location":"#this-version-has-been-modified-and-optimized-by-abhinav-mishra","title":"This version has been modified and optimized by Abhinav Mishra.","text":"<p>The tfopt package estimates transcriptional regulation using mRNA and TF time-series data through constrained optimization.</p>"},{"location":"#tfoptevol","title":"tfopt/evol","text":"<p>Global evolutionary optimization using pymoo (NSGA-II, AGEMOEA, SMSEMOA):</p> <ul> <li>Multi-objective loss (fit error, \u03b1 and \u03b2 constraint violations)  </li> <li>Parallel evaluation, Excel export, and HTML/plot reports</li> </ul>"},{"location":"#tfoptlocal","title":"tfopt/local","text":"<p>Local constrained optimization using SciPy solvers (SLSQP):</p> <ul> <li>Fast deterministic optimization under linear constraints  </li> <li>Numba-accelerated objectives, identical output and reports as <code>evol</code></li> </ul>"},{"location":"#tfoptobjfn","title":"tfopt/objfn","text":"<p>Shared objective logic and prediction functions for both backends</p>"},{"location":"#tfoptoptcon","title":"tfopt/optcon","text":"<p>Data construction and constraint generation from TF\u2013mRNA interaction files</p>"},{"location":"#tfoptutils","title":"tfopt/utils","text":"<p>Input parsing, Excel + plot output, and HTML report generation</p>"},{"location":"#features-at-a-glance","title":"Features at a Glance","text":"<ul> <li>\ud83e\uddec Mechanistic ODE Models: Distributive, successive, and random phosphorylation models.</li> <li>\ud83e\uddea Parameter Estimation: Both normal and sequential fitting modes.</li> <li>\ud83e\udde0 Sensitivity Analysis: Morris method to analyze model response to parameters.</li> <li>\ud83e\uddf0 Steady-State Calculations: Compute initial conditions for all model types.</li> <li>\ud83d\udcca Visualization Tools: Model fit plots, PCA/t-SNE visualizations, and HTML reports.</li> <li>\ud83d\udd01 Modular Design: Easy to extend and customize each component.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#option-1-pip-virtualenv-debianubuntufedora","title":"Option 1: pip + virtualenv (Debian/Ubuntu/Fedora)","text":""},{"location":"#for-debianubuntu","title":"For Debian/Ubuntu","text":"<pre><code>sudo apt update &amp;&amp; sudo apt install -y python3 python3-pip python3-venv git\n</code></pre>"},{"location":"#for-fedora","title":"For Fedora","text":"<pre><code>sudo dnf install -y python3 python3-pip python3-virtualenv git\n</code></pre>"},{"location":"#setup","title":"Setup","text":"<pre><code>git clone git@github.com:bibymaths/phoskintime.git\ncd phoskintime\n\n# Create and activate a virtual environment\npython3 -m venv venv\nsource venv/bin/activate\n\n# Install dependencies\npip install --upgrade pip\npip install -r requirements.txt\n</code></pre>"},{"location":"#option-2-poetry-pyprojecttoml","title":"Option 2: Poetry + <code>pyproject.toml</code>","text":""},{"location":"#install-poetry-all-platforms","title":"Install Poetry (all platforms)","text":"<pre><code>curl -sSL https://install.python-poetry.org | python3 -# Or: pip install poetry\n</code></pre>"},{"location":"#modules","title":"Modules","text":"<ul> <li><code>bin/</code>: Entry point (<code>main.py</code>) to run the full pipeline.</li> <li><code>config/</code>: Constants, CLI parsing, and logging setup.</li> <li><code>models/</code>: Distributive, successive, and random ODE systems.</li> <li><code>paramest/</code>: Estimation logic (normal, sequential, adaptive).</li> <li><code>steady/</code>: Model-specific steady-state calculators.</li> <li><code>sensitivity/</code>: Morris sensitivity analysis.</li> <li><code>utils/</code>: IO, table generation, and result handling.</li> <li><code>plotting/</code>: Visualizations for model fits, sensitivity, PCA, and more.</li> </ul>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>This project originated as part of my master's thesis work at Theoretical Biophysics group (now, Klipp-Linding Lab), Humboldt Universit\u00e4t zu Berlin.</p> <ul> <li>Conceptual framework and mathematical modeling were developed under the supervision of Prof. Dr. Dr. H.C. Edda Klipp.</li> <li>Experimental datasets were provided by the (Retd. Prof.) Dr. Rune Linding.</li> <li>The subpackage <code>tfopt</code> is an optimized and efficient derivative of original work by my colleague Julius Normann, adapted with permission.</li> </ul> <p>I am especially grateful to Ivo Maintz for his generous technical support, enabling seamless experimentation with packages and server setups.</p> <ul> <li>The package is built on the shoulders of giants, leveraging the power of NumPy, SciPy, Matplotlib, and Pandas for numerical computations and data handling. </li> <li>The package also utilizes Numba for JIT compilation, enhancing performance for computationally intensive tasks.</li> <li>The package is designed to be compatible with Python 3.8+ and is tested on various platforms, including Windows, macOS, and Linux. </li> </ul>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#data-standardization-cleanup","title":"Data Standardization &amp; Cleanup","text":""},{"location":"reference/#processing.cleanup","title":"<code>processing.cleanup</code>","text":""},{"location":"reference/#processing.cleanup.process_collecttri","title":"<code>process_collecttri()</code>","text":"<p>Processes the CollecTRI file to clean and filter mRNA-TF interactions. Removes complex interactions, filters by target genes, and saves the result.</p>"},{"location":"reference/#processing.cleanup.format_site","title":"<code>format_site(site)</code>","text":"<p>Formats a phosphorylation site string.</p> <p>If the input is NaN or an empty string, returns an empty string. If the input contains an underscore ('_'), splits the string into two parts, converts the first part to uppercase, and appends the second part unchanged. Otherwise, converts the entire string to uppercase.</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>str</code> <p>The phosphorylation site string to format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The formatted phosphorylation site string.</p>"},{"location":"reference/#processing.cleanup.process_msgauss","title":"<code>process_msgauss()</code>","text":"<p>Processes the MS Gaussian data file to generate time series data.</p> <p>This function performs the following steps: 1. Loads the <code>MS_Gaussian_updated_09032023.csv</code> file. 2. Computes the transformed values as 2^(predict_mean). 3. Pivots the data to create a time series for each (GeneID, Psite) pair. 4. Renames the time point columns to <code>x1</code> to <code>x14</code> and formats the <code>Psite</code> column. 5. Saves the cleaned time series to <code>input1.csv</code>. 6. Filters the data to keep only rows where <code>Psite</code> starts with <code>Y_</code>, <code>S_</code>, <code>T_</code>, or is empty. 7. Saves the filtered time series to <code>input1.csv</code>.</p> Outputs <ul> <li><code>input1.csv</code>: Cleaned and filtered time series data.</li> </ul> Prints <ul> <li>A message indicating that the time series data has been saved.</li> </ul> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the input file is not found in the specified directory.</p>"},{"location":"reference/#processing.cleanup.process_msgauss_std","title":"<code>process_msgauss_std()</code>","text":"<p>Processes the MS Gaussian data file to compute transformed means and standard deviations.</p> <p>This function performs the following steps: 1. Loads the <code>MS_Gaussian_updated_09032023.csv</code> file. 2. Computes transformed values as 2^(predict_mean) and propagates errors using the formula:    sigma_y = 2^(x) * ln(2) * sigma_x. 3. Pivots the data to create time series for each (GeneID, Psite) pair for both means and standard deviations. 4. Merges the pivoted data for means and standard deviations. 5. Filters the data to keep only rows where <code>Psite</code> starts with <code>Y_</code>, <code>S_</code>, <code>T_</code>, or is empty. 6. Saves the resulting data to <code>input1_wstd.csv</code>.</p> Outputs <ul> <li><code>input1_wstd.csv</code>: Cleaned time series data with transformed means and standard deviations.</li> </ul> Prints <ul> <li>A message indicating that the time series data with standard deviations has been saved.</li> </ul> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the input file is not found in the specified directory.</p>"},{"location":"reference/#processing.cleanup.process_routlimma","title":"<code>process_routlimma()</code>","text":"<p>Processes the Rout Limma table to generate time series data for mRNA.</p> <p>This function performs the following steps: 1. Loads the <code>Rout_LimmaTable.csv</code> file. 2. Selects specific columns related to time points and conditions. 3. Renames the selected columns to a standardized format (<code>x1</code> to <code>x9</code>). 4. Converts the values in the renamed columns using the formula <code>2^(value)</code>. 5. Saves the resulting time series data to <code>input3.csv</code>.</p> Outputs <ul> <li><code>input3.csv</code>: Cleaned and transformed time series data for mRNA.</li> </ul> Prints <ul> <li>A message indicating that the time series data has been saved.</li> </ul> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the input file <code>Rout_LimmaTable.csv</code> is not found in the specified directory.</p>"},{"location":"reference/#processing.cleanup.update_gene_symbols","title":"<code>update_gene_symbols(filename)</code>","text":"<p>Updates the GeneID column in a CSV file by mapping GeneIDs to gene/protein symbols.</p> <p>This function reads a CSV file, queries the MyGeneInfo database to map GeneIDs to their corresponding gene/protein symbols, and writes the updated DataFrame back to the same file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the CSV file to be updated. The file must contain a 'GeneID' column.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified file does not exist.</p> <code>ValueError</code> <p>If the 'GeneID' column is missing in the file.</p> Outputs <ul> <li>The input file is updated in place with the 'GeneID' column replaced by gene/protein symbols.</li> </ul> Prints <ul> <li>A progress bar indicating the mapping process.</li> <li>A message confirming the update of gene symbols in the file.</li> </ul>"},{"location":"reference/#processing.cleanup.move_processed_files","title":"<code>move_processed_files()</code>","text":"<p>Moves or copies processed files to their respective directories.</p> <p>This function organizes processed files into specific directories for transcription factor optimization (TFOpt) and kinase optimization (KinOpt). It creates the target directories if they do not exist and moves or copies the files based on whether they have already been moved.</p> Directories <ul> <li><code>../tfopt/data</code>: Target directory for TFOpt files.</li> <li><code>../kinopt/data</code>: Target directory for KinOpt files.</li> </ul> Files <ul> <li>KinOpt files: [\"input1.csv\", \"input2.csv\"]</li> <li>TFOpt files: [\"input1.csv\", \"input3.csv\", \"input4.csv\"]</li> </ul> Behavior <ul> <li>If a file has already been moved, it is copied to the target directory.</li> <li>If a file has not been moved, it is moved to the target directory.</li> <li>If a file does not exist, a message is printed.</li> </ul> Prints <ul> <li>Messages indicating whether files were moved, copied, or not found.</li> </ul>"},{"location":"reference/#optimization-results-mapping","title":"Optimization Results Mapping","text":""},{"location":"reference/#processing.map","title":"<code>processing.map</code>","text":""},{"location":"reference/#processing.map.map_optimization_results","title":"<code>map_optimization_results(file_path)</code>","text":"<p>Reads the TF-mRNA optimization results from an Excel file and maps mRNA to each TF.</p> <p>This function processes the 'Alpha Values' sheet of the provided Excel file to extract non-zero optimization results, groups mRNA by TF, and merges the results with additional data from a CSV file containing TF, Psite, and Kinase information. The final DataFrame is cleaned and formatted for further analysis.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the Excel file containing TF-mRNA optimization results.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame containing the mapped TF, mRNA, Psite, and Kinase information.</p>"},{"location":"reference/#processing.map.create_cytoscape_table","title":"<code>create_cytoscape_table(mapping_csv_path)</code>","text":"<p>Creates a Cytoscape-compatible edge table from a mapping file.</p> <p>Parameters:</p> Name Type Description Default <code>mapping_csv_path</code> <code>str</code> <p>Path to the input CSV file with columns: TF, mRNA, Psite, Kinase</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: Edge table with columns [Source, Target, Interaction]</p>"},{"location":"reference/#processing.map.generate_nodes","title":"<code>generate_nodes(edge_df)</code>","text":"<p>Infers node types for Cytoscape visualization: - All nodes default to 'Kinase' - Nodes that are only targets of 'regulates' are labeled 'mRNA'</p> <p>Parameters:</p> Name Type Description Default <code>edge_df</code> <code>DataFrame</code> <p>Must have columns ['Source', 'Target', 'Interaction']</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame with columns ['Node', 'Type']</p>"},{"location":"reference/#kinase-phosphorylation-optimization","title":"Kinase-Phosphorylation Optimization","text":""},{"location":"reference/#evolutionary-algorithms","title":"Evolutionary Algorithms","text":""},{"location":"reference/#kinopt.evol.config.constants","title":"<code>kinopt.evol.config.constants</code>","text":""},{"location":"reference/#kinopt.evol.config.logconf","title":"<code>kinopt.evol.config.logconf</code>","text":""},{"location":"reference/#kinopt.evol.exporter.plotout","title":"<code>kinopt.evol.exporter.plotout</code>","text":""},{"location":"reference/#kinopt.evol.exporter.plotout.plot_residuals_for_gene","title":"<code>plot_residuals_for_gene(gene, gene_data)</code>","text":"<p>Generates and saves combined residual-related plots for one gene with all psites in the legend.</p> <p>Parameters:</p> Name Type Description Default <code>gene</code> <code>str</code> <p>Gene identifier.</p> required <code>gene_data</code> <code>dict</code> <p>Dictionary with keys 'psites', 'observed', 'estimated', and 'residuals' containing data for all psites.</p> required <code>TIME_POINTS</code> <code>ndarray or list</code> <p>Time points corresponding to the series.</p> required"},{"location":"reference/#kinopt.evol.exporter.plotout.opt_analyze_nsga","title":"<code>opt_analyze_nsga(problem, result, F, pairs, approx_ideal, approx_nadir, asf_i, pseudo_i, n_evals, hv, hist, val, hist_cv_avg, k, igd, best_objectives, waterfall_df, convergence_df, alpha_values, beta_values)</code>","text":"<p>Generates and saves various plots related to optimization results. This includes design space plots, objective space plots, convergence plots, and parameter trend plots.</p> <p>:param problem: :param result: :param F: :param pairs: :param approx_ideal: :param approx_nadir: :param asf_i: :param pseudo_i: :param n_evals: :param hv: :param hist: :param val: :param hist_cv_avg: :param k: :param igd: :param best_objectives: :param waterfall_df: :param convergence_df: :param alpha_values: :param beta_values:</p>"},{"location":"reference/#kinopt.evol.exporter.plotout.opt_analyze_de","title":"<code>opt_analyze_de(long_df, convergence_df, ordered_optimizer_runs, x_values, y_values, val)</code>","text":"<p>Generates and saves various plots related to optimization results. This includes waterfall plots, convergence plots, parameter trend plots, and parameter scan plots.</p> <p>:param long_df: :param convergence_df: :param ordered_optimizer_runs: :param x_values: :param y_values: :param val:</p>"},{"location":"reference/#kinopt.evol.exporter.sheetutils","title":"<code>kinopt.evol.exporter.sheetutils</code>","text":""},{"location":"reference/#kinopt.evol.exporter.sheetutils.output_results","title":"<code>output_results(P_initial, P_init_dense, P_estimated, residuals, alpha_values, beta_values, result, timepoints, OUT_FILE)</code>","text":"<p>This function is responsible for exporting the results of the optimization process to an Excel file. It creates multiple sheets in the Excel file, each containing different types of data related to the optimization results. The function also generates plots for the residuals of each gene. The data is organized in a structured manner, making it easy to analyze and interpret the results. The function takes the following parameters:</p> <p>:param P_initial: :param P_init_dense: :param P_estimated: :param residuals: :param alpha_values: :param beta_values: :param result: :param timepoints: :param OUT_FILE:</p>"},{"location":"reference/#kinopt.evol.objfn.minfndiffevo","title":"<code>kinopt.evol.objfn.minfndiffevo</code>","text":""},{"location":"reference/#kinopt.evol.objfn.minfndiffevo.PhosphorylationOptimizationProblem","title":"<code>PhosphorylationOptimizationProblem</code>","text":"<p>               Bases: <code>ElementwiseProblem</code></p> <p>Custom optimization problem for phosphorylation analysis.</p> <p>Defines the constraints, bounds, and objective function for optimizing alpha and beta parameters across gene-psite-kinase relationships.</p> <p>Attributes:</p> Name Type Description <code>P_initial</code> <code>dict</code> <p>Mapping of gene-psite pairs to kinase relationships and time-series data.</p> <code>P_initial_array</code> <code>ndarray</code> <p>Observed time-series data for gene-psite pairs.</p> <code>K_index</code> <code>dict</code> <p>Mapping of kinases to their respective psite data.</p> <code>K_array</code> <code>ndarray</code> <p>Array containing time-series data for kinase-psite combinations.</p> <code>gene_psite_counts</code> <code>list</code> <p>Number of kinases per gene-psite combination.</p> <code>beta_counts</code> <code>dict</code> <p>Mapping of kinase indices to the number of associated psites.</p>"},{"location":"reference/#kinopt.evol.objfn.minfndiffevo.PhosphorylationOptimizationProblem.__init__","title":"<code>__init__(P_initial, P_initial_array, K_index, K_array, gene_psite_counts, beta_counts, **kwargs)</code>","text":"<p>Initializes the optimization problem with given data and constraints.</p> <p>Parameters:</p> Name Type Description Default <code>P_initial</code> <code>dict</code> <p>Mapping of gene-psite pairs to kinase relationships and time-series data.</p> required <code>P_initial_array</code> <code>ndarray</code> <p>Observed time-series data for gene-psite pairs.</p> required <code>K_index</code> <code>dict</code> <p>Mapping of kinases to their respective psite data.</p> required <code>K_array</code> <code>ndarray</code> <p>Array containing time-series data for kinase-psite combinations.</p> required <code>gene_psite_counts</code> <code>list</code> <p>Number of kinases per gene-psite combination.</p> required <code>beta_counts</code> <code>dict</code> <p>Mapping of kinase indices to the number of associated psites.</p> required"},{"location":"reference/#kinopt.evol.objfn.minfndiffevo.PhosphorylationOptimizationProblem.objective_function","title":"<code>objective_function(params)</code>","text":"<p>Computes the loss value for the given parameters using the selected loss type.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>Decision variables vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Computed loss value.</p>"},{"location":"reference/#kinopt.evol.objfn.minfnnsgaii","title":"<code>kinopt.evol.objfn.minfnnsgaii</code>","text":""},{"location":"reference/#kinopt.evol.objfn.minfnnsgaii.PhosphorylationOptimizationProblem","title":"<code>PhosphorylationOptimizationProblem</code>","text":"<p>               Bases: <code>ElementwiseProblem</code></p> <p>Multi-objective optimization problem for phosphorylation analysis.</p> <p>Objectives: - Minimize sum of squared residuals (main objective). - Minimize violations of constraints for alpha (secondary objective). - Minimize violations of constraints for beta (tertiary objective).</p>"},{"location":"reference/#kinopt.evol.objfn.minfnnsgaii.PhosphorylationOptimizationProblem.__init__","title":"<code>__init__(P_initial, P_initial_array, K_index, K_array, gene_psite_counts, beta_counts, **kwargs)</code>","text":"<p>Initializes the multi-objective optimization problem.</p> <p>Parameters:</p> Name Type Description Default <code>P_initial</code> <code>dict</code> <p>Mapping of gene-psite pairs to kinase relationships and time-series data.</p> required <code>P_initial_array</code> <code>ndarray</code> <p>Observed time-series data for gene-psite pairs.</p> required <code>K_index</code> <code>dict</code> <p>Mapping of kinases to their respective psite data.</p> required <code>K_array</code> <code>ndarray</code> <p>Array containing time-series data for kinase-psite combinations.</p> required <code>gene_psite_counts</code> <code>list</code> <p>Number of kinases per gene-psite combination.</p> required <code>beta_counts</code> <code>dict</code> <p>Mapping of kinase indices to the number of associated psites.</p> required"},{"location":"reference/#kinopt.evol.objfn.minfnnsgaii.PhosphorylationOptimizationProblem.objective_function","title":"<code>objective_function(params)</code>","text":"<p>Computes the loss value for the given parameters using the selected loss type.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>Decision variables vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Computed loss value.</p>"},{"location":"reference/#kinopt.evol.opt.optrun","title":"<code>kinopt.evol.opt.optrun</code>","text":""},{"location":"reference/#kinopt.evol.opt.optrun.run_optimization","title":"<code>run_optimization(P_initial, P_initial_array, K_index, K_array, gene_psite_counts, beta_counts, PhosphorylationOptimizationProblem)</code>","text":"<p>Sets up and runs the multi-objective optimization problem for phosphorylation using an NSGA2 algorithm and a thread pool for parallelization.</p> <p>Parameters:</p> Name Type Description Default <code>P_initial,</code> <code>(P_initial_array, K_index, K_array, gene_psite_counts, beta_counts)</code> <p>Data structures describing the problem (time-series data, kinases, etc.).</p> required <code>PhosphorylationOptimizationProblem</code> <code>class</code> <p>The custom problem class to be instantiated.</p> required <p>Returns:</p> Name Type Description <code>result</code> <p>The pymoo result object containing the optimized population and history.</p> <code>exec_time</code> <p>Execution time for the optimization.</p>"},{"location":"reference/#kinopt.evol.opt.optrun.post_optimization_nsga","title":"<code>post_optimization_nsga(result, weights=np.array([1.0, 1.0, 1.0]), ref_point=np.array([3, 1, 1]))</code>","text":"<p>Post-processes the result of a multi-objective optimization run. 1) Extracts the Pareto front and computes a weighted score to pick a 'best' solution. 2) Gathers metrics like Hypervolume (HV) and IGD+ over the optimization history. 3) Logs feasibility generation info, saves waterfall and convergence data to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <p>The final result object from the optimizer (e.g., a pymoo result).</p> required <code>weights</code> <code>ndarray</code> <p>Array of length 3 for weighting the objectives.</p> <code>array([1.0, 1.0, 1.0])</code> <code>ref_point</code> <code>ndarray</code> <p>Reference point for hypervolume computations.</p> <code>array([3, 1, 1])</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary with keys: 'best_solution': The best individual from the weighted scoring. 'best_objectives': Its corresponding objective vector. 'optimized_params': The individual's decision variables (X). 'scores': Weighted scores for each solution in the Pareto front. 'best_index': The index of the best solution according to weighted score. 'hist_hv': The hypervolume per generation. 'hist_igd': The IGD+ per generation. 'convergence_df': The DataFrame with iteration vs. best objective value     for each iteration in the result history.</p>"},{"location":"reference/#kinopt.evol.opt.optrun.post_optimization_de","title":"<code>post_optimization_de(result, alpha_values, beta_values)</code>","text":"<p>Post-processes the result of a multi-objective optimization run. 1) Extracts the Pareto front and computes a weighted score to pick a 'best' solution. 2) Gathers metrics like Hypervolume (HV) and IGD+ over the optimization history. 3) Logs feasibility generation info, saves waterfall and convergence data to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <p>The final result object from the optimizer (e.g., a pymoo result).</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary with keys: 'best_solution': The best individual from the weighted scoring. 'best_objectives': Its corresponding objective vector. 'optimized_params': The individual's decision variables (X). 'scores': Weighted scores for each solution in the Pareto front. 'best_index': The index of the best solution according to weighted score. 'hist_hv': The hypervolume per generation. 'hist_igd': The IGD+ per generation. 'convergence_df': The DataFrame with iteration vs. best objective value     for each iteration in the result history.</p>"},{"location":"reference/#kinopt.evol.optcon.construct","title":"<code>kinopt.evol.optcon.construct</code>","text":""},{"location":"reference/#kinopt.evol.optcon.construct.pipeline","title":"<code>pipeline(input1_path: str, input2_path: str, time_series_columns: list[str], scaling_method: str, split_point: float, segment_points: list[float], estimate_missing_kinases: bool, kinase_to_psites: dict[str, int])</code>","text":"<p>Constructs the pipeline for the optimization process. This function orchestrates the loading of data, scaling, and the construction of the P_initial and K_array structures. It returns the necessary data structures for the optimization process. The function takes the following parameters:</p> <p>:param input1_path: Path to the first CSV file (HGNC data) :param input2_path: Path to the second CSV file (kinase interactions) :param time_series_columns: List of time series columns to extract :param scaling_method: Method for scaling the data :param split_point: Split point for scaling :param segment_points: Segment points for scaling :param estimate_missing_kinases: Boolean flag for estimating missing kinases :param kinase_to_psites: Dictionary mapping kinases to their respective psites</p> <p>:return: Tuple containing:     - full_hgnc_df (pd.DataFrame): The scaled data from input1     - interaction_df (pd.DataFrame): The subset/merged DataFrame from input2     - observed (pd.DataFrame): Subset of full_hgnc_df merged with interaction_df     - P_initial (dict): Initial mapping of gene-psite pairs to kinase relationships and time-series data     - P_initial_array (np.ndarray): Array containing observed time-series data for gene-psite pairs     - K_index (dict): Mapping of kinases to their respective psite data     - K_array (np.ndarray): Array containing time-series data for kinase-psite combinations     - beta_counts (dict): Mapping of kinase indices to the number of associated psites     - gene_psite_counts (list): Number of kinases per gene-psite combination     - n (int): Number of decision variables in the optimization problem</p>"},{"location":"reference/#kinopt.evol.utils.iodata","title":"<code>kinopt.evol.utils.iodata</code>","text":""},{"location":"reference/#kinopt.evol.utils.iodata.format_duration","title":"<code>format_duration(seconds)</code>","text":"<p>Returns a formatted string representing the duration in seconds, minutes, or hours. The format is: - seconds: \"xx.xx sec\" - minutes: \"xx.xx min\" - hours: \"xx.xx hr\"</p> <p>:param seconds: :return:</p>"},{"location":"reference/#kinopt.evol.utils.iodata.load_and_scale_data","title":"<code>load_and_scale_data(estimate_missing, scaling_method, split_point, seg_points)</code>","text":"<p>Loads the full HGNC data and kinase interaction data, applies scaling to the time-series columns, and subsets/merges them. The first file is the full HGNC data, and the second file contains kinase interactions. The function also handles the conversion of kinases from string format to list format.</p> <p>:param estimate_missing: :param scaling_method: :param split_point: :param seg_points:</p> <p>:return: full_hgnc_df (pd.DataFrame): The scaled data from input1 interaction_df (pd.DataFrame): The subset/merged DataFrame from input2 observed (pd.DataFrame): Subset of full_hgnc_df merged with interaction_df</p>"},{"location":"reference/#kinopt.evol.utils.iodata.apply_scaling","title":"<code>apply_scaling(df, time_series_columns, method, split_point, segment_points)</code>","text":"<p>Applies different scaling methods to the time-series columns of a DataFrame. Args:     df (pd.DataFrame): The DataFrame containing the time-series data.     time_series_columns (list): List of columns to be scaled.     method (str): The scaling method to apply ('min_max', 'log', 'temporal', 'segmented', 'slope', 'cumulative').     split_point (int): Column index for temporal scaling.     segment_points (list): List of column indices for segmented scaling. :returns:     pd.DataFrame: The DataFrame with scaled time-series columns.</p>"},{"location":"reference/#kinopt.evol.utils.iodata.create_report","title":"<code>create_report(results_dir: str, output_file: str = 'report.html')</code>","text":"<p>Creates a single global report HTML file from all gene folders inside the results directory.</p> <p>For each gene folder (e.g. \"ABL2\"), the report will include:   - All PNG plots and interactive HTML plots displayed in a grid with three plots per row.   - Each plot is confined to a fixed size of 900px by 900px.   - Data tables from XLSX or CSV files in the gene folder are displayed below the plots, one per row.</p> <p>Parameters:</p> Name Type Description Default <code>results_dir</code> <code>str</code> <p>Path to the root results directory.</p> required <code>output_file</code> <code>str</code> <p>Name of the generated global report file (placed inside results_dir).</p> <code>'report.html'</code>"},{"location":"reference/#kinopt.evol.utils.iodata.organize_output_files","title":"<code>organize_output_files(*directories)</code>","text":"<p>Organizes output files from the optimization process into separate folders based on protein names. Each protein's files are moved into a folder named after the protein. Any remaining files that do not match the protein pattern are moved to a \"General\" folder.</p> <p>:param directories: List of directories to organize.</p>"},{"location":"reference/#kinopt.evol.utils.params","title":"<code>kinopt.evol.utils.params</code>","text":""},{"location":"reference/#kinopt.evol.utils.params.extract_parameters","title":"<code>extract_parameters(P_initial, gene_psite_counts, K_index, optimized_params)</code>","text":"<p>Extracts the optimized alpha and beta values from the optimized parameters. The function organizes the values into dictionaries for easy access and interpretation. The alpha values are associated with gene-psite pairs and their corresponding kinases, while the beta values are associated with kinase-psite pairs. The function also logs the optimized values for transparency and debugging purposes.</p> <p>The function takes the following parameters: :param P_initial: :param gene_psite_counts: :param K_index: :param optimized_params:</p> <p>:return: - alpha_values: Dictionary mapping (gene, psite) to a dictionary of kinases and their alpha values. - beta_values: Dictionary mapping (kinase, psite) to their corresponding beta values.</p>"},{"location":"reference/#kinopt.evol.utils.params.compute_metrics","title":"<code>compute_metrics(optimized_params, P_initial, P_initial_array, K_index, K_array, gene_psite_counts, beta_counts, n)</code>","text":"<p>Computes various error metrics to evaluate the performance of the optimization process. The function calculates the Mean Squared Error (MSE), Root Mean Squared Error (RMSE), Mean Absolute Error (MAE), Mean Absolute Percentage Error (MAPE), and R-squared value. These metrics provide insights into the accuracy of the estimated time series compared to the observed data.</p> <p>The function takes the following parameters: :param optimized_params: :param P_initial: :param P_initial_array: :param K_index: :param K_array: :param gene_psite_counts: :param beta_counts: :param n:</p> <p>:return: - P_estimated: Estimated time series matrix for all gene-psite combinations. - residuals: Residuals between observed and estimated values. - mse: Mean Squared Error. - rmse: Root Mean Squared Error. - mae: Mean Absolute Error. - mape: Mean Absolute Percentage Error. - r_squared: R-squared value.</p>"},{"location":"reference/#gradient-based-algorithms","title":"Gradient-Based Algorithms","text":""},{"location":"reference/#kinopt.local.config.constants","title":"<code>kinopt.local.config.constants</code>","text":""},{"location":"reference/#kinopt.local.config.constants.parse_args","title":"<code>parse_args()</code>","text":"<p>Parses command-line arguments for the optimization script. This function uses argparse to handle various parameters related to the optimization process. The parameters include bounds for the optimization, loss function types, estimation of missing kinases, scaling methods for time-series data, and the optimization method to be used. The function returns a tuple containing the parsed arguments.</p> <p>:return: A tuple containing the parsed arguments.     - lower_bound (float): Lower bound for the optimization.     - upper_bound (float): Upper bound for the optimization.     - loss_type (str): Type of loss function to use.     - estimate_missing (bool): Whether to estimate missing kinase-psite values.     - scaling_method (str): Method for scaling time-series data.     - split_point (int): Split point for temporal scaling.     - segment_points (list of int): Segment points for segmented scaling.     - method (str): Optimization method to use.</p>"},{"location":"reference/#kinopt.local.config.logconf","title":"<code>kinopt.local.config.logconf</code>","text":""},{"location":"reference/#kinopt.local.exporter.plotout","title":"<code>kinopt.local.exporter.plotout</code>","text":""},{"location":"reference/#kinopt.local.exporter.plotout.plot_fits_for_gene","title":"<code>plot_fits_for_gene(gene, gene_data, real_timepoints)</code>","text":"<p>Function to plot the observed and estimated phosphorylation levels for a gene. It generates two plots: 1. A full timepoints plot showing all timepoints. 2. A short timepoints plot showing only the first 7 timepoints. The plots are saved as PNG files in the specified output directory.</p> <p>Parameters: gene (str): The name of the gene. gene_data (dict): A dictionary containing the observed and estimated phosphorylation levels for the gene. real_timepoints (list): A list of timepoints corresponding to the observed and estimated data.</p>"},{"location":"reference/#kinopt.local.exporter.plotout.plot_cumulative_residuals","title":"<code>plot_cumulative_residuals(gene, gene_data, real_timepoints)</code>","text":"<p>Function to plot the cumulative residuals for each psite of a gene. It generates a plot showing the cumulative residuals over time. The plot is saved as a PNG file in the specified output directory.</p> <p>Parameters: gene (str): The name of the gene. gene_data (dict): A dictionary containing the residuals for each psite of the gene. real_timepoints (list): A list of timepoints corresponding to the observed and estimated data.</p>"},{"location":"reference/#kinopt.local.exporter.plotout.plot_autocorrelation_residuals","title":"<code>plot_autocorrelation_residuals(gene, gene_data, real_timepoints)</code>","text":"<p>Function to plot the autocorrelation of residuals for each psite of a gene. It generates a plot showing the autocorrelation values over time. The plot is saved as a PNG file in the specified output directory.</p> <p>Parameters: gene (str): The name of the gene. gene_data (dict): A dictionary containing the residuals for each psite of the gene. real_timepoints (list): A list of timepoints corresponding to the observed and estimated data.</p>"},{"location":"reference/#kinopt.local.exporter.plotout.plot_histogram_residuals","title":"<code>plot_histogram_residuals(gene, gene_data, real_timepoints)</code>","text":"<p>Function to plot histograms of residuals for each psite of a gene. It generates a histogram showing the distribution of residuals. The plot is saved as a PNG file in the specified output directory.</p> <p>Parameters: gene (str): The name of the gene. gene_data (dict): A dictionary containing the residuals for each psite of the gene. real_timepoints (list): A list of timepoints corresponding to the observed and estimated data.</p>"},{"location":"reference/#kinopt.local.exporter.plotout.plot_qqplot_residuals","title":"<code>plot_qqplot_residuals(gene, gene_data, real_timepoints)</code>","text":"<p>Function to plot QQ plots of residuals for each psite of a gene. It generates a QQ plot showing the quantiles of the residuals against the quantiles of a normal distribution. The plot is saved as a PNG file in the specified output directory.</p> <p>Parameters: gene (str): The name of the gene. gene_data (dict): A dictionary containing the residuals for each psite of the gene. real_timepoints (list): A list of timepoints corresponding to the observed and estimated data.</p>"},{"location":"reference/#kinopt.local.exporter.sheetutils","title":"<code>kinopt.local.exporter.sheetutils</code>","text":""},{"location":"reference/#kinopt.local.exporter.sheetutils.plot_fits_for_gene","title":"<code>plot_fits_for_gene(gene, gene_data, real_timepoints)</code>","text":"<p>Function to plot the observed and estimated phosphorylation levels for a gene. It generates two plots: 1. A full timepoints plot showing all timepoints. 2. A short timepoints plot showing only the first 7 timepoints. The plots are saved as PNG files in the specified output directory.</p> <p>Parameters: gene (str): The name of the gene. gene_data (dict): A dictionary containing the observed and estimated phosphorylation levels for the gene. real_timepoints (list): A list of timepoints corresponding to the observed and estimated data.</p>"},{"location":"reference/#kinopt.local.exporter.sheetutils.plot_cumulative_residuals","title":"<code>plot_cumulative_residuals(gene, gene_data, real_timepoints)</code>","text":"<p>Function to plot the cumulative residuals for each psite of a gene. It generates a plot showing the cumulative residuals over time. The plot is saved as a PNG file in the specified output directory.</p> <p>Parameters: gene (str): The name of the gene. gene_data (dict): A dictionary containing the residuals for each psite of the gene. real_timepoints (list): A list of timepoints corresponding to the observed and estimated data.</p>"},{"location":"reference/#kinopt.local.exporter.sheetutils.plot_autocorrelation_residuals","title":"<code>plot_autocorrelation_residuals(gene, gene_data, real_timepoints)</code>","text":"<p>Function to plot the autocorrelation of residuals for each psite of a gene. It generates a plot showing the autocorrelation values over time. The plot is saved as a PNG file in the specified output directory.</p> <p>Parameters: gene (str): The name of the gene. gene_data (dict): A dictionary containing the residuals for each psite of the gene. real_timepoints (list): A list of timepoints corresponding to the observed and estimated data.</p>"},{"location":"reference/#kinopt.local.exporter.sheetutils.plot_histogram_residuals","title":"<code>plot_histogram_residuals(gene, gene_data, real_timepoints)</code>","text":"<p>Function to plot histograms of residuals for each psite of a gene. It generates a histogram showing the distribution of residuals. The plot is saved as a PNG file in the specified output directory.</p> <p>Parameters: gene (str): The name of the gene. gene_data (dict): A dictionary containing the residuals for each psite of the gene. real_timepoints (list): A list of timepoints corresponding to the observed and estimated data.</p>"},{"location":"reference/#kinopt.local.exporter.sheetutils.plot_qqplot_residuals","title":"<code>plot_qqplot_residuals(gene, gene_data, real_timepoints)</code>","text":"<p>Function to plot QQ plots of residuals for each psite of a gene. It generates a QQ plot showing the quantiles of the residuals against the quantiles of a normal distribution. The plot is saved as a PNG file in the specified output directory.</p> <p>Parameters: gene (str): The name of the gene. gene_data (dict): A dictionary containing the residuals for each psite of the gene. real_timepoints (list): A list of timepoints corresponding to the observed and estimated data.</p>"},{"location":"reference/#kinopt.local.exporter.sheetutils.output_results","title":"<code>output_results(P_initial, P_init_dense, P_estimated, residuals, alpha_values, beta_values, result, mse, rmse, mae, mape, r_squared)</code>","text":"<p>Function to output the results of the optimization process. It logs the optimized alpha and beta values, optimization summary, error metrics, and generates plots for each gene. It also writes the results to an Excel file with multiple sheets.</p> <p>The sheets include: - Alpha Values: Optimized alpha values for each gene and psite. - Beta Values: Optimized beta values for each kinase and psite. - Summary: Summary of the optimization process. - Observed: Observed time-series data for each gene and psite. - Estimated: Estimated time-series data for each gene and psite. - Residuals: Residuals for each gene and psite.</p> <p>:param P_initial: :param P_init_dense: :param P_estimated: :param residuals: :param alpha_values: :param beta_values: :param result: :param mse: :param rmse: :param mae: :param mape: :param r_squared:</p>"},{"location":"reference/#kinopt.local.objfn.minfn","title":"<code>kinopt.local.objfn.minfn</code>","text":""},{"location":"reference/#kinopt.local.opt.optrun","title":"<code>kinopt.local.opt.optrun</code>","text":""},{"location":"reference/#kinopt.local.opt.optrun.run_optimization","title":"<code>run_optimization(obj_fun, params_initial, opt_method, bounds, constraints)</code>","text":"<p>Run optimization using the specified method.</p> <p>:param obj_fun: :param params_initial: :param opt_method: :param bounds: :param constraints: :return: result, optimized parameters</p>"},{"location":"reference/#kinopt.local.optcon.construct","title":"<code>kinopt.local.optcon.construct</code>","text":""},{"location":"reference/#kinopt.local.utils.iodata","title":"<code>kinopt.local.utils.iodata</code>","text":""},{"location":"reference/#kinopt.local.utils.iodata.format_duration","title":"<code>format_duration(seconds)</code>","text":"<p>Formats a duration in seconds into a human-readable string. - If less than 60 seconds, returns in seconds. - If less than 3600 seconds, returns in minutes. - If more than 3600 seconds, returns in hours.</p> <p>:param seconds: :return: Formatted string</p>"},{"location":"reference/#kinopt.local.utils.iodata.load_and_scale_data","title":"<code>load_and_scale_data(estimate_missing, scaling_method, split_point, seg_points)</code>","text":"<p>Load and scale the data from the specified input files.</p> <p>:param estimate_missing: :param scaling_method: :param split_point: :param seg_points: :return: Time series data, interaction data, observed data</p>"},{"location":"reference/#kinopt.local.utils.iodata.apply_scaling","title":"<code>apply_scaling(df, cols, method, split_point, seg_points)</code>","text":"<p>Apply scaling to the specified columns of a DataFrame based on the given method. The scaling methods include: - 'min_max': Min-Max scaling - 'log': Logarithmic scaling - 'temporal': Temporal scaling (two segments) - 'segmented': Segmented scaling (multiple segments) - 'slope': Slope scaling - 'cumulative': Cumulative scaling</p> <p>:param df: :param cols: :param method: :param split_point: :param seg_points: :return: df</p>"},{"location":"reference/#kinopt.local.utils.iodata.create_report","title":"<code>create_report(results_dir: str, output_file: str = 'report.html')</code>","text":"<p>Creates a single global report HTML file from all gene folders inside the results directory.</p> <p>For each gene folder (e.g. \"ABL2\"), the report will include:   - All PNG plots and interactive HTML plots displayed in a grid with three plots per row.   - Each plot is confined to a fixed size of 900px by 900px.   - Data tables from XLSX or CSV files in the gene folder are displayed below the plots, one per row.</p> <p>Parameters:</p> Name Type Description Default <code>results_dir</code> <code>str</code> <p>Path to the root results directory.</p> required <code>output_file</code> <code>str</code> <p>Name of the generated global report file (placed inside results_dir).</p> <code>'report.html'</code>"},{"location":"reference/#kinopt.local.utils.iodata.organize_output_files","title":"<code>organize_output_files(*directories)</code>","text":"<p>Function to organize output files into protein-specific folders. It moves files matching the pattern 'protein_name_*.{json,svg,png,html,csv,xlsx}' into a folder named after the protein (e.g., 'ABL2') and moves all other files into a 'General' folder within the same directory.</p> <p>:param directories:</p>"},{"location":"reference/#kinopt.local.utils.params","title":"<code>kinopt.local.utils.params</code>","text":""},{"location":"reference/#kinopt.local.utils.params.extract_parameters","title":"<code>extract_parameters(P_initial, gene_kinase_counts, total_alpha, unique_kinases, K_index, optimized_params)</code>","text":"<p>Extracts the alpha and beta parameters from the optimized parameters.</p> <p>:param P_initial: :param gene_kinase_counts: :param total_alpha: :param unique_kinases: :param K_index: :param optimized_params: :return: Alpha and beta values as dictionaries</p>"},{"location":"reference/#kinopt.local.utils.params.compute_metrics","title":"<code>compute_metrics(optimized_params, P_init_dense, t_max, gene_alpha_starts, gene_kinase_counts, gene_kinase_idx, total_alpha, kinase_beta_starts, kinase_beta_counts, K_data, K_indices, K_indptr)</code>","text":"<p>Computes the estimated series and various metrics based on the optimized parameters.</p> <p>:param optimized_params: :param P_init_dense: :param t_max: :param gene_alpha_starts: :param gene_kinase_counts: :param gene_kinase_idx: :param total_alpha: :param kinase_beta_starts: :param kinase_beta_counts: :param K_data: :param K_indices: :param K_indptr: :return: Estimated series, residuals, MSE, RMSE, MAE, MAPE, R-squared</p>"},{"location":"reference/#fitting-analysis-feasibility","title":"Fitting Analysis &amp; Feasibility","text":""},{"location":"reference/#kinopt.fitanalysis.helpers.postfit","title":"<code>kinopt.fitanalysis.helpers.postfit</code>","text":""},{"location":"reference/#kinopt.fitanalysis.helpers.postfit.goodnessoffit","title":"<code>goodnessoffit(estimated, observed)</code>","text":"<p>Function to plot the goodness of fit for estimated and observed values. It creates scatter plots with confidence intervals and labels for genes outside the 95% CI. The function also calculates KL divergence and generates a heatmap for optimization progression.</p> <p>:param estimated: :param observed:</p>"},{"location":"reference/#kinopt.fitanalysis.helpers.postfit.reshape_alpha_beta","title":"<code>reshape_alpha_beta(alpha_values, beta_values)</code>","text":"<p>Function to reshape alpha and beta values for plotting. It renames columns and creates a new 'Parameter' column for each type of value.</p> <p>:param alpha_values: :param beta_values:</p> <p>:returns: - pd.DataFrame: Reshaped DataFrame containing 'GeneID', 'Value', and 'Parameter' columns.</p>"},{"location":"reference/#kinopt.fitanalysis.helpers.postfit.perform_pca","title":"<code>perform_pca(df)</code>","text":"<p>Perform PCA analysis on the given DataFrame. The DataFrame should contain a 'Value' column for PCA analysis. The function returns a DataFrame with PCA results and additional columns for type and gene/psite information.</p> <p>:param df: DataFrame containing the data for PCA analysis. :return: DataFrame with PCA results and additional columns.</p>"},{"location":"reference/#kinopt.fitanalysis.helpers.postfit.plot_pca","title":"<code>plot_pca(result_df_sorted, y_axis_column)</code>","text":"<p>Plot PCA or t-SNE results for each gene/psite. The function creates scatter plots with different markers for alpha and beta parameters, and adds labels for each point. The function also adjusts text labels to avoid overlap using the adjustText library.</p> <p>:param result_df_sorted: DataFrame containing PCA or t-SNE results. :param y_axis_column: Column name for the y-axis values in the plot.</p>"},{"location":"reference/#kinopt.fitanalysis.helpers.postfit.perform_tsne","title":"<code>perform_tsne(scaled_data, df)</code>","text":"<p>Perform t-SNE analysis on the given scaled data. The function returns a DataFrame with t-SNE results and additional columns for type and gene/psite information.</p> <p>:param scaled_data: :param df:</p> <p>:return: - pd.DataFrame: DataFrame with t-SNE results and additional columns.</p>"},{"location":"reference/#kinopt.fitanalysis.helpers.postfit.additional_plots","title":"<code>additional_plots(df, scaled_data, alpha_values, beta_values, residuals_df)</code>","text":"<p>Function to create additional plots including CDF, KDE, Boxplot, and Hierarchical Clustering.</p> <p>:param df: :param scaled_data: :param alpha_values: :param beta_values: :param residuals_df:</p>"},{"location":"reference/#kinopt.fitanalysis.helpers.postfit.create_sankey_from_network","title":"<code>create_sankey_from_network(output_dir, data, title)</code>","text":"<p>Creates a Sankey diagram from the given data and saves it as an HTML file.</p> <p>This function processes the input data to generate nodes and links for a Sankey diagram. It assigns colors to nodes and links based on their attributes and values, and uses Plotly to render the diagram. The resulting diagram is saved as an HTML file in the specified output directory.</p> <p>:param output_dir: str     The directory where the Sankey diagram HTML file will be saved. :param data: pd.DataFrame     A DataFrame containing the data for the Sankey diagram. It must include the following columns:     - 'Source': The source node of the link.     - 'Target': The target node of the link.     - 'Value': The value of the link, which determines the flow size. :param title: str     The title of the Sankey diagram.</p> <p>The function performs the following steps: 1. Initializes nodes and links for the Sankey diagram. 2. Maps node labels to indices and assigns colors to nodes. 3. Processes the data to create links between nodes, assigning colors based on link values. 4. Builds the Sankey diagram using Plotly. 5. Adds a color bar to explain the flow gradient. 6. Saves the Sankey diagram as an HTML file in the specified output directory.</p>"},{"location":"reference/#kinopt.fitanalysis.helpers.postfit.important_connections","title":"<code>important_connections(output_dir, data, top_n=20)</code>","text":"<p>Extracts the top N most important connections based on their absolute values and saves them to a CSV file.</p> <p>:param output_dir: str     The directory where the CSV file will be saved. :param data: pd.DataFrame     A DataFrame containing the connections with columns 'Source', 'Target', and 'Value'. :param top_n: int, optional     The number of top connections to extract (default is 20).</p> <p>The function sorts the connections by their absolute values in descending order, selects the top N connections, and saves them to a CSV file named 'top_connections.csv' in the specified output directory.</p>"},{"location":"reference/#kinopt.optimality.KKT","title":"<code>kinopt.optimality.KKT</code>","text":""},{"location":"reference/#kinopt.optimality.KKT.generate_latex_table","title":"<code>generate_latex_table(summary_dict, table_caption, table=None)</code>","text":"<p>Function to generate a LaTeX table from a summary dictionary. The table is formatted for use in a LaTeX document.</p> <p>:param summary_dict: Dictionary containing summary data. :param table_caption: Caption for the LaTeX table. :param table: Optional table object to format. :return: LaTeX table as a string.</p>"},{"location":"reference/#kinopt.optimality.KKT.print_primal_feasibility_results","title":"<code>print_primal_feasibility_results(primal_summary, alpha_violations, beta_violations, logger_obj=None)</code>","text":"<p>Logs the primal feasibility summary and violation details.</p>"},{"location":"reference/#kinopt.optimality.KKT.print_sensitivity_and_active_constraints","title":"<code>print_sensitivity_and_active_constraints(sensitivity_summary, active_constraints_summary, logger_obj=None)</code>","text":"<p>Logs the sensitivity summary and active constraints summary.</p>"},{"location":"reference/#kinopt.optimality.KKT.plot_constraint_violations","title":"<code>plot_constraint_violations(alpha_violations, beta_violations, out_dir)</code>","text":"<p>Function to plot constraint violations for alpha and beta values. It creates a stacked bar plot showing the violations for each protein. The top 5 proteins with the highest violations are highlighted in red.</p> <p>Parameters:</p> Name Type Description Default <code>alpha_violations</code> <code>Series</code> <p>Series containing alpha constraint violations.</p> required <code>beta_violations</code> <code>Series</code> <p>Series containing beta constraint violations.</p> required <code>out_dir</code> <code>str</code> <p>Directory to save the plot.</p> required"},{"location":"reference/#kinopt.optimality.KKT.plot_sensitivity_analysis","title":"<code>plot_sensitivity_analysis(sensitivity_analysis, out_dir)</code>","text":"<p>Function to plot sensitivity analysis results. It creates a horizontal bar plot showing the mean, max, and min sensitivity for each protein.</p> <p>Parameters:</p> Name Type Description Default <code>sensitivity_analysis</code> <code>DataFrame</code> <p>DataFrame containing sensitivity analysis results.</p> required <code>out_dir</code> <code>str</code> <p>Directory to save the plot.</p> required"},{"location":"reference/#kinopt.optimality.KKT.process_excel_results","title":"<code>process_excel_results(file_path=OUT_FILE)</code>","text":"<p>Function to process the Excel results file. It reads the alpha and beta values, estimated and observed values, validates normalization constraints, computes residuals and gradients, and generates LaTeX tables for the residuals and sensitivity summaries. It also performs sensitivity analysis and identifies high sensitivity sites. The results are returned as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the Excel file containing results.</p> <code>OUT_FILE</code> <p>Returns:     dict: Dictionary containing the processed results, including alpha and beta values,           estimated and observed values, constraint violations, residuals summary,           sensitivity summary, and high sensitivity sites.</p>"},{"location":"reference/#kinopt.optimality.KKT.post_optimization_results","title":"<code>post_optimization_results()</code>","text":"<p>Function to process and visualize the results of the optimization. It reads the results from an Excel file, processes the data, and generates plots for constraint violations and sensitivity analysis. It also prints the primal feasibility results and sensitivity summaries. The results are returned as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary containing the processed results, including alpha and beta values,   estimated and observed values, constraint violations, residuals summary,   sensitivity summary, and high sensitivity sites.</p>"},{"location":"reference/#tf-mrna-optimization","title":"TF-mRNA Optimization","text":""},{"location":"reference/#evolutionary-algorithms_1","title":"Evolutionary Algorithms","text":""},{"location":"reference/#tfopt.evol.config.constants","title":"<code>tfopt.evol.config.constants</code>","text":""},{"location":"reference/#tfopt.evol.config.constants.parse_args","title":"<code>parse_args()</code>","text":"<p>Parse command line arguments for the PhosKinTime optimization problem. This function uses argparse to handle input parameters for the optimization process. The parameters include: - lower_bound: Lower bound for the optimization variables (default: -2). - upper_bound: Upper bound for the optimization variables (default: 2). - loss_type: Type of loss function to use (default: 0).     Options:     0: MSE     1: MAE     2: soft L1     3: Cauchy     4: Arctan     5: Elastic Net     6: Tikhonov - optimizer: Global Evolutionary Optimization method (default: 0).     Options:     0: NGSA2     1: SMSEMOA     2: AGEMOEA</p> <p>:returns - lower_bound: Lower bound for the optimization variables. - upper_bound: Upper bound for the optimization variables. - loss_type: Type of loss function to use. - optimizer: Global Evolutionary Optimization method. :rtype: tuple :raises argparse.ArgumentError: If an invalid argument is provided. :raises SystemExit: If the script is run with invalid arguments.</p>"},{"location":"reference/#tfopt.evol.config.logconf","title":"<code>tfopt.evol.config.logconf</code>","text":""},{"location":"reference/#tfopt.evol.exporter.plotout","title":"<code>tfopt.evol.exporter.plotout</code>","text":""},{"location":"reference/#tfopt.evol.exporter.plotout.plot_estimated_vs_observed","title":"<code>plot_estimated_vs_observed(predictions, expression_matrix, gene_ids, time_points, regulators, tf_protein_matrix, tf_ids, num_targets, save_path=OUT_DIR)</code>","text":"<p>Plot the estimated vs observed expression levels for a set of genes. This function generates two plots for each gene: 1. A full time series plot showing the observed and estimated expression levels. 2. A plot showing the observed and estimated expression levels for the first 5 time points. Additionally, it plots the protein signals for the regulators of each gene. The plots are saved as PNG files in the specified save path.</p> <p>:param predictions: Predicted expression levels. :param expression_matrix: Observed expression levels. :param gene_ids: List of gene identifiers. :param time_points: Time points for the expression data. :param regulators: Matrix of regulators for each gene. :param tf_protein_matrix: Matrix of protein signals for each transcription factor. :param tf_ids: List of transcription factor identifiers. :param num_targets: Number of target genes to plot. :param save_path: Path to save the plots. :type predictions: np.ndarray :type expression_matrix: np.ndarray :type gene_ids: list :type time_points: np.ndarray :type regulators: np.ndarray :type tf_protein_matrix: np.ndarray :type tf_ids: list :type num_targets: int :type save_path: str</p>"},{"location":"reference/#tfopt.evol.exporter.plotout.compute_predictions","title":"<code>compute_predictions(x, regulators, protein_mat, psite_tensor, n_reg, T_use, n_mRNA, beta_start_indices, num_psites)</code>","text":"<p>Compute the predicted expression levels based on the optimization variables. This function calculates the predicted expression levels for each mRNA based on the optimization variables, the regulators, and the protein and phosphorylation site tensors.</p> <p>:param x: :param regulators: :param protein_mat: :param psite_tensor: :param n_reg: :param T_use: :param n_mRNA: :param beta_start_indices: :param num_psites: :return: predictions</p>"},{"location":"reference/#tfopt.evol.exporter.sheetutils","title":"<code>tfopt.evol.exporter.sheetutils</code>","text":""},{"location":"reference/#tfopt.evol.exporter.sheetutils.save_results_to_excel","title":"<code>save_results_to_excel(gene_ids, tf_ids, final_alpha, final_beta, psite_labels_arr, expression_matrix, predictions, objective_value, reg_map, filename=OUT_FILE)</code>","text":"<p>Save the optimization results to an Excel file. This function creates multiple sheets in the Excel file to store different types of data, including alpha values, beta values, residuals, observed values, estimated values, and optimization results. Each sheet is formatted with appropriate column names and data types. The function also calculates various metrics (MSE, MAE, MAPE, R^2) to evaluate the performance of the optimization.</p> <p>:param gene_ids: :param tf_ids: :param final_alpha: :param final_beta: :param psite_labels_arr: :param expression_matrix: :param predictions: :param objective_value: :param reg_map: :param filename:</p>"},{"location":"reference/#tfopt.evol.objfn.minfn","title":"<code>tfopt.evol.objfn.minfn</code>","text":""},{"location":"reference/#tfopt.evol.objfn.minfn.TFOptimizationMultiObjectiveProblem","title":"<code>TFOptimizationMultiObjectiveProblem</code>","text":"<p>               Bases: <code>Problem</code></p> <p>Originally implemented by Julius Normann.</p> <p>This version has been modified and optimized for consistency &amp; speed in submodules by Abhinav Mishra.</p> <p>Multi-objective optimization problem for TF optimization. This class defines a multi-objective optimization problem for the transcription factor (TF) optimization problem. It inherits from the <code>Problem</code> class in the pymoo library. The problem is defined with three objectives: f1 (error), f2 (alpha violation), and f3 (beta violation).</p> <p>The problem is initialized with the following parameters: - n_var: Number of decision variables. - n_mRNA: Number of mRNA genes. - n_TF: Number of transcription factors. - n_reg: Number of regulators. - n_psite_max: Maximum number of phosphorylation sites. - n_alpha: Number of alpha parameters. - mRNA_mat: Matrix of measured mRNA values. - regulators: Matrix of TF regulators for each mRNA. - protein_mat: Matrix of TF protein time series. - psite_tensor: Tensor of phosphorylation site signals. - T_use: Number of time points used. - beta_start_indices: Integer array giving the starting index (in the \u03b2\u2013segment)                       for each TF. - num_psites: Integer array with the actual number of phosphorylation sites for each TF. - no_psite_tf: Boolean array indicating if the TF has no phosphorylation sites. - xl: Lower bounds for the decision variables. - xu: Upper bounds for the decision variables. - kwargs: Additional keyword arguments.</p>"},{"location":"reference/#tfopt.evol.objfn.minfn.TFOptimizationMultiObjectiveProblem.__init__","title":"<code>__init__(n_var, n_mRNA, n_TF, n_reg, n_psite_max, n_alpha, mRNA_mat, regulators, protein_mat, psite_tensor, T_use, beta_start_indices, num_psites, no_psite_tf, xl=None, xu=None, **kwargs)</code>","text":"<p>Initialize the multi-objective optimization problem.</p> <p>:param n_var: :param n_mRNA: :param n_TF: :param n_reg: :param n_psite_max: :param n_alpha: :param mRNA_mat: :param regulators: :param protein_mat: :param psite_tensor: :param T_use: :param beta_start_indices: :param num_psites: :param no_psite_tf: :param xl: :param xu: :param kwargs:</p>"},{"location":"reference/#tfopt.evol.objfn.minfn.objective_","title":"<code>objective_(x, mRNA_mat, regulators, protein_mat, psite_tensor, n_reg, T_use, n_mRNA, beta_start_indices, num_psites, loss_type, lam1=0.001, lam2=0.001)</code>","text":"<p>Computes a loss value using one of several loss functions.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code> </code> <p>Decision vector.</p> required <code>mRNA_mat</code> <code> </code> <p>(n_mRNA x T_use) measured mRNA values.</p> required <code>regulators</code> <code> </code> <p>(n_mRNA x n_reg) indices of TF regulators for each mRNA.</p> required <code>protein_mat</code> <code> </code> <p>(n_TF x T_use) TF protein time series.</p> required <code>psite_tensor</code> <code> </code> <p>(n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros).</p> required <code>n_reg</code> <code> </code> <p>Maximum number of regulators per mRNA.</p> required <code>T_use</code> <code> </code> <p>Number of time points used.</p> required <code>n_mRNA,</code> <code>n_TF</code> <p>Number of mRNA and TF respectively.</p> required <code>beta_start_indices</code> <p>Integer array giving the starting index (in the \u03b2\u2013segment)                  for each TF.</p> required <code>num_psites</code> <code> </code> <p>Integer array with the actual number of PSites for each TF.</p> required <code>loss_type</code> <code> </code> <p>Integer indicating the loss type (0: MSE, 1: MAE, 2: soft L1,                  3: Cauchy, 4: Arctan, 5: Elastic Net, 6: Tikhonov).</p> required <code>lam1,</code> <code>lam2</code> <p>Regularization parameters (used for loss_type 5 and 6).</p> required <p>Returns:</p> Type Description <p>The computed loss (a scalar).</p>"},{"location":"reference/#tfopt.evol.opt.optrun","title":"<code>tfopt.evol.opt.optrun</code>","text":""},{"location":"reference/#tfopt.evol.opt.optrun.run_optimization","title":"<code>run_optimization(problem, total_dim, optimizer)</code>","text":"<p>Run the optimization using the specified algorithm and problem. This function sets up the algorithm parameters, initializes the optimizer, and runs the optimization process.</p> <p>:param problem: :param total_dim: :param optimizer: :return: result</p>"},{"location":"reference/#tfopt.evol.optcon.construct","title":"<code>tfopt.evol.optcon.construct</code>","text":""},{"location":"reference/#tfopt.evol.optcon.construct.build_fixed_arrays","title":"<code>build_fixed_arrays(mRNA_ids, mRNA_mat, TF_ids, protein_dict, psite_dict, psite_labels_dict, reg_map)</code>","text":"<p>Builds fixed-shape arrays from the input data. Returns:   - mRNA_mat: array of shape (n_mRNA, T)   - regulators: array of shape (n_mRNA, n_reg) with indices into TF_ids.   - protein_mat: array of shape (n_TF, T)   - psite_tensor: array of shape (n_TF, n_psite_max, T), padded with zeros.   - n_reg: maximum number of regulators per mRNA.   - n_psite_max: maximum number of PSites among TFs.   - psite_labels_arr: list (length n_TF) of lists of PSite names (padded with empty strings).   - num_psites: array of length n_TF with the actual number of PSites for each TF.</p>"},{"location":"reference/#tfopt.evol.optcon.filter","title":"<code>tfopt.evol.optcon.filter</code>","text":""},{"location":"reference/#tfopt.evol.optcon.filter.load_raw_data","title":"<code>load_raw_data()</code>","text":"<p>Load raw data from files. This includes mRNA data, TF data, and regulation maps. The function returns the following: - mRNA_ids: List of mRNA gene identifiers. - mRNA_mat: Matrix of mRNA expression data. - mRNA_time_cols: Time points for mRNA data. - TF_ids: List of transcription factor identifiers. - protein_dict: Dictionary mapping TF_ids to their protein data. - psite_dict: Dictionary mapping TF_ids to their phosphorylation site data. - psite_labels_dict: Dictionary mapping TF_ids to their phosphorylation site labels. - TF_time_cols: Time points for TF data. - reg_map: Regulation map, mapping mRNA genes to their regulators.</p> <p>:return: mRNA_ids, mRNA_mat, mRNA_time_cols, TF_ids, protein_dict, psite_dict, psite_labels_dict, TF_time_cols, reg_map</p>"},{"location":"reference/#tfopt.evol.optcon.filter.filter_mrna","title":"<code>filter_mrna(mRNA_ids, mRNA_mat, reg_map)</code>","text":"<p>Filter mRNA genes to only those with regulators present in the regulation map. This function returns the filtered mRNA_ids and their corresponding expression matrix.</p> <p>:param mRNA_ids: List of mRNA gene identifiers. :param mRNA_mat: Matrix of mRNA expression data. :param reg_map: Regulation map, mapping mRNA genes to their regulators. :return: filtered_mRNA_ids, filtered_mRNA_mat</p>"},{"location":"reference/#tfopt.evol.optcon.filter.update_regulations","title":"<code>update_regulations(mRNA_ids, reg_map, TF_ids)</code>","text":"<p>Update the regulation map to only include relevant transcription factors. This function modifies the reg_map in place and returns a set of relevant transcription factors.</p> <p>:param mRNA_ids: List of mRNA gene identifiers. :param reg_map: Regulation map, mapping mRNA genes to their regulators. :param TF_ids: List of transcription factor identifiers. :return: relevant_TFs: Set of relevant transcription factors.</p>"},{"location":"reference/#tfopt.evol.optcon.filter.filter_TF","title":"<code>filter_TF(TF_ids, protein_dict, psite_dict, psite_labels_dict, relevant_TFs)</code>","text":"<p>Filter transcription factors to only those present in the relevant_TFs set. This function returns the filtered TF_ids and their corresponding protein and phosphorylation site data. This is important for ensuring that only relevant transcription factors are included in the analysis. :param TF_ids: List of transcription factor identifiers. :param protein_dict: Dictionary mapping TF_ids to their protein data. :param psite_dict: Dictionary mapping TF_ids to their phosphorylation site data. :param psite_labels_dict: Dictionary mapping TF_ids to their phosphorylation site labels. :param relevant_TFs: Set of relevant transcription factors. :return: filtered TF_ids, protein_dict, psite_dict, psite_labels_dict</p>"},{"location":"reference/#tfopt.evol.optcon.filter.determine_T_use","title":"<code>determine_T_use(mRNA_mat, TF_time_cols)</code>","text":"<p>Determine the number of time points to use for the analysis. This function takes the mRNA matrix and TF time columns as input and returns the minimum number of time points available across both datasets. This is important for ensuring that the analysis is consistent and comparable across different datasets. The function checks the shape of the mRNA matrix and the length of the TF time columns to determine the minimum number of time points. If the mRNA matrix has fewer time points than the TF time columns, it uses the number of time points in the mRNA matrix. If the TF time columns have fewer time points, it uses that value instead. This ensures that the analysis is based on the same number of time points for both mRNA and TF data.</p> <p>:param mRNA_mat: Matrix of mRNA expression data. :param TF_time_cols: Time points for TF data. :return: T_use: Number of time points to use for the analysis.</p>"},{"location":"reference/#tfopt.evol.utils.iodata","title":"<code>tfopt.evol.utils.iodata</code>","text":""},{"location":"reference/#tfopt.evol.utils.iodata.load_mRNA_data","title":"<code>load_mRNA_data(filename=INPUT3)</code>","text":"<p>Load mRNA data from a CSV file. The file is expected to have a \"GeneID\" column and time columns for expression data. The function returns a list of mRNA gene identifiers, a matrix of expression data, and the time columns. The mRNA_ids are converted to strings, and the expression data is converted to a numpy array of floats. The time columns are extracted from the DataFrame, excluding the \"GeneID\" column. The function returns:     - mRNA_ids: List of mRNA gene identifiers (strings).     - mRNA_mat: Numpy array of expression data (floats).     - time_cols: List of time columns (excluding \"GeneID\").</p> <p>:param filename: str :return: mRNA_ids, mRNA_mat, time_cols</p>"},{"location":"reference/#tfopt.evol.utils.iodata.load_TF_data","title":"<code>load_TF_data(filename=INPUT1)</code>","text":"<p>Load TF data from a CSV file. The file is expected to have a \"GeneID\" column, a \"Psite\" column, and time columns for protein data. The function returns a list of TF gene identifiers, a dictionary mapping TF_ids to their protein data, a dictionary mapping TF_ids to their phosphorylation site data, a dictionary mapping TF_ids to their phosphorylation site labels, and the time columns. The TF_ids are converted to strings, and the protein data is stored in a dictionary with TF_ids as keys. The phosphorylation site data is stored in a list for each TF_id, and the phosphorylation site labels are also stored in a list. The time columns are being extracted from the DataFrame, excluding the \"GeneID\" and \"Psite\" columns. The function returns:     - TF_ids: List of TF gene identifiers (strings).     - protein_dict: Dictionary mapping TF_ids to their protein data (numpy arrays).     - psite_dict: Dictionary mapping TF_ids to their phosphorylation site data (lists of numpy arrays).     - psite_labels_dict: Dictionary mapping TF_ids to their phosphorylation site labels (lists of strings).     - time_cols: List of time columns (excluding \"GeneID\" and \"Psite\").</p> <p>:param filename: str :return: TF_ids, protein_dict, psite_dict, psite_labels_dict, time_cols</p>"},{"location":"reference/#tfopt.evol.utils.iodata.load_regulation","title":"<code>load_regulation(filename=INPUT4)</code>","text":"<p>Load regulation data from a CSV file. The file is expected to have \"Source\" and \"Target\" columns. The function returns a dictionary mapping mRNA gene identifiers to their regulators (TFs). The mRNA gene identifiers and TF identifiers are converted to strings and stripped of whitespace. The function returns:     - reg_map: Dictionary mapping mRNA gene identifiers to their regulators (TFs).</p> <p>:param filename: str :return: reg_map</p>"},{"location":"reference/#tfopt.evol.utils.iodata.create_report","title":"<code>create_report(results_dir: str, output_file: str = 'report.html')</code>","text":"<p>Creates a single global report HTML file from all gene folders inside the results directory.</p> <p>For each gene folder (e.g. \"ABL2\"), the report will include:   - All PNG plots and interactive HTML plots displayed in a grid with three plots per row.   - Each plot is confined to a fixed size of 900px by 900px.   - Data tables from XLSX or CSV files in the gene folder are displayed below the plots, one per row.</p> <p>Parameters:</p> Name Type Description Default <code>results_dir</code> <code>str</code> <p>Path to the root results directory.</p> required <code>output_file</code> <code>str</code> <p>Name of the generated global report file (placed inside results_dir).</p> <code>'report.html'</code>"},{"location":"reference/#tfopt.evol.utils.iodata.organize_output_files","title":"<code>organize_output_files(*directories)</code>","text":"<p>Organizes output files from multiple directories into separate folders for each protein. Files are moved into folders named after the protein identifier extracted from the filename. Remaining files are moved to a \"General\" folder. Args:     directories (str): List of directories to organize.</p>"},{"location":"reference/#tfopt.evol.utils.iodata.format_duration","title":"<code>format_duration(seconds)</code>","text":"<p>Format a duration in seconds into a human-readable string. The function converts the duration into hours, minutes, or seconds, depending on the length of the duration. Args:     seconds (float): Duration in seconds. Returns:     str: Formatted duration string.</p>"},{"location":"reference/#tfopt.evol.utils.params","title":"<code>tfopt.evol.utils.params</code>","text":""},{"location":"reference/#tfopt.evol.utils.params.create_no_psite_array","title":"<code>create_no_psite_array(n_TF, num_psites, psite_labels_arr)</code>","text":"<p>Create an array indicating whether each TF has no phosphorylation sites. A TF is considered to have no phosphorylation sites if: 1. The number of phosphorylation sites is zero. 2. All labels for the phosphorylation sites are empty strings. This function is used to determine the initial guess for the beta parameters in the optimization process.</p> <p>:param n_TF: :param num_psites: :param psite_labels_arr: :return: array of booleans indicating no phosphorylation sites for each TF</p>"},{"location":"reference/#tfopt.evol.utils.params.compute_beta_indices","title":"<code>compute_beta_indices(num_psites, n_TF)</code>","text":"<p>Compute the starting indices for the beta parameters for each TF. The beta parameters are stored in a flat array, and this function computes the starting index for each TF based on the number of phosphorylation sites. The starting index for the beta parameters of TF i is given by: beta_start_indices[i] = sum(1 + num_psites[j] for j in range(i)) This function is used to extract the beta parameters from the flat array during the optimization process.</p> <p>:param num_psites: array of integers indicating the number of phosphorylation sites for each TF :param n_TF: number of TFs :return: beta_start_indices: array of integers indicating the starting index for each TF          cum: total number of beta parameters</p>"},{"location":"reference/#tfopt.evol.utils.params.create_initial_guess","title":"<code>create_initial_guess(n_mRNA, n_reg, n_TF, num_psites, no_psite_tf)</code>","text":"<p>Create the initial guess for the optimization variables. The initial guess is a flat array containing the alpha and beta parameters. The alpha parameters are initialized to 1.0 / n_reg for each mRNA-regulator pair. The beta parameters are initialized to 1.0 for the protein and 1.0 / (1 + num_psites[i]) for each phosphorylation site of TF i. The beta parameters for TFs with no phosphorylation sites are initialized to 1.0. The initial guess is used as the starting point for the optimization process. The initial guess is a flat array of length n_alpha + n_beta_total, where n_alpha is the number of alpha parameters and n_beta_total is the total number of beta parameters. The alpha parameters are stored in the first n_alpha elements of the array, and the beta parameters are stored in the remaining elements. The beta parameters are stored in the order of the TFs, with the protein parameter first followed by the phosphorylation site parameters. The beta parameters for TFs with no phosphorylation sites are stored as a single value. The beta parameters for TFs with phosphorylation sites are stored as a vector of length 1 + num_psites[i].</p> <p>:param n_mRNA: :param n_reg: :param n_TF: :param num_psites: :param no_psite_tf: :return: initial guess array, n_alpha</p>"},{"location":"reference/#tfopt.evol.utils.params.create_bounds","title":"<code>create_bounds(n_alpha, n_beta_total, lb, ub)</code>","text":"<p>Create the lower and upper bounds for the optimization variables. The lower bounds are set to 0 for the alpha parameters and lb for the beta parameters. The upper bounds are set to 1 for the alpha parameters and ub for the beta parameters. The bounds are used to constrain the optimization process and ensure that the parameters are within a reasonable range. The bounds are stored in two separate arrays: xl and xu. The xl array contains the lower bounds for each parameter, and the xu array contains the upper bounds.</p> <p>:param n_alpha: number of alpha parameters :param n_beta_total: total number of beta parameters :param lb: lower bound for beta parameters :param ub: upper bound for beta parameters :return: xl: lower bounds array          xu: upper bounds array</p>"},{"location":"reference/#tfopt.evol.utils.params.get_parallel_runner","title":"<code>get_parallel_runner()</code>","text":"<p>Get a parallel runner for multi-threading. This function uses the lscpu command to determine the number of threads available on the system and creates a ThreadPool with that number of threads. The ThreadPool is used to parallelize the optimization process and speed up the computation.</p> <p>:return: runner: StarmapParallelization object for parallel execution             pool: ThreadPool object for managing threads</p>"},{"location":"reference/#tfopt.evol.utils.params.extract_best_solution","title":"<code>extract_best_solution(res, n_alpha, n_mRNA, n_reg, n_TF, num_psites, beta_start_indices)</code>","text":"<p>Extract the best solution from the optimization results. This function finds the best solution based on the Pareto front, which is a set of non-dominated solutions in the objective space. The best solution is determined by minimizing the weighted sum of the objectives. The alpha parameters are reshaped into a matrix of shape (n_mRNA, n_reg), and the beta parameters are extracted based on the starting indices and the number of phosphorylation sites for each TF. The beta parameters are stored in a list of arrays, where each array corresponds to a TF and contains the protein parameter and the phosphorylation site parameters. The function returns the final alpha and beta parameters, the best objectives, and the final decision variables.</p> <p>:param res: optimization results :param n_alpha: number of alpha parameters :param n_mRNA: number of mRNAs :param n_reg: number of regulators :param n_TF: number of transcription factors :param num_psites: number of phosphorylation sites for each TF :param beta_start_indices: starting indices for the beta parameters</p> <p>:return: final_alpha: final alpha parameters (n_mRNA x n_reg)             final_beta: final beta parameters (n_TF x (1 + num_psites))             best_objectives: best objectives (3 objectives)             final_x: final decision variables (flat array)</p>"},{"location":"reference/#tfopt.evol.utils.params.print_alpha_mapping","title":"<code>print_alpha_mapping(mRNA_ids, reg_map, TF_ids, final_alpha)</code>","text":"<p>Print the mapping of transcription factors (TFs) to mRNAs with their corresponding alpha values. This function iterates through the mRNA IDs and their corresponding regulators, and logs the TFs that are present in the final alpha matrix. The alpha values are printed for each TF that regulates the mRNA.</p> <p>:param mRNA_ids: List of mRNA gene identifiers. :param reg_map: Regulation map, mapping mRNA genes to their regulators. :param TF_ids: List of transcription factor identifiers. :param final_alpha: Final alpha parameters (n_mRNA x n_reg).</p>"},{"location":"reference/#tfopt.evol.utils.params.print_beta_mapping","title":"<code>print_beta_mapping(TF_ids, final_beta, psite_labels_arr)</code>","text":"<p>Print the mapping of transcription factors (TFs) to their beta parameters. This function iterates through the TF IDs and their corresponding beta values, and logs the beta values for each TF. The beta values are printed for the protein and each phosphorylation site, with appropriate labels.</p> <p>:param TF_ids: List of transcription factor identifiers. :param final_beta: Final beta parameters (n_TF x (1 + num_psites)). :param psite_labels_arr: Array of phosphorylation site labels for each TF.</p>"},{"location":"reference/#gradient-based-algorithms_1","title":"Gradient-Based Algorithms","text":""},{"location":"reference/#tfopt.local.config.constants","title":"<code>tfopt.local.config.constants</code>","text":""},{"location":"reference/#tfopt.local.config.constants.parse_args","title":"<code>parse_args()</code>","text":"<p>Parse command line arguments for the PhosKinTime optimization problem. This function uses argparse to handle input parameters for the optimization process. The parameters include: - lower_bound: Lower bound for the optimization variables (default: -2). - upper_bound: Upper bound for the optimization variables (default: 2). - loss_type: Type of loss function to use (default: 0).     Options:     0: MSE     1: MAE     2: soft L1     3: Cauchy     4: Arctan     5: Elastic Net     6: Tikhonov</p> <p>:return: lower_bound, upper_bound, loss_type</p>"},{"location":"reference/#tfopt.local.config.logconf","title":"<code>tfopt.local.config.logconf</code>","text":""},{"location":"reference/#tfopt.local.exporter.plotout","title":"<code>tfopt.local.exporter.plotout</code>","text":""},{"location":"reference/#tfopt.local.exporter.plotout.plot_estimated_vs_observed","title":"<code>plot_estimated_vs_observed(predictions, expression_matrix, gene_ids, time_points, regulators, tf_protein_matrix, tf_ids, num_targets, save_path=OUT_DIR)</code>","text":"<p>Plots the estimated vs observed values for a given set of genes and their corresponding TFs. The function generates two types of plots: 1. A full time series plot showing the observed and estimated values for each gene. 2. A plot showing the first 5 time points for each gene. Additionally, it generates an interactive plot using Plotly for each gene.</p> <p>:param predictions: 2D numpy array of predicted values. :param expression_matrix: 2D numpy array of observed values. :param gene_ids: List of gene identifiers. :param time_points: 1D numpy array of time points. :param regulators: 2D numpy array of regulators for each gene. :param tf_protein_matrix: 2D numpy array of TF protein signals. :param tf_ids: List of TF identifiers. :param num_targets: Number of target genes to plot. :param save_path: Directory path to save the plots.</p>"},{"location":"reference/#tfopt.local.exporter.sheetutils","title":"<code>tfopt.local.exporter.sheetutils</code>","text":""},{"location":"reference/#tfopt.local.exporter.sheetutils.save_results_to_excel","title":"<code>save_results_to_excel(gene_ids, tf_ids, final_alpha, final_beta, psite_labels_arr, expression_matrix, predictions, objective_value, reg_map, filename=OUT_FILE)</code>","text":"<p>Save the optimization results to an Excel file. This function creates multiple sheets in the Excel file, each containing different aspects of the optimization results, including alpha values, beta values, residuals, observed values, estimated values, and optimization metrics. Each sheet is formatted with appropriate column names and data types. The function also computes various metrics such as Mean Squared Error (MSE), Mean Absolute Error (MAE), Mean Absolute Percentage Error (MAPE), and R-squared score to evaluate the performance of the optimization.</p> <p>:param gene_ids: List of gene identifiers. :param tf_ids: List of TF identifiers. :param final_alpha: 2D numpy array of alpha values. :param final_beta: 2D numpy array of beta values. :param psite_labels_arr: List of post-translational modification labels. :param expression_matrix: 2D numpy array of observed values. :param predictions: 2D numpy array of predicted values. :param objective_value: Objective value of the optimization. :param reg_map: Dictionary mapping genes to their regulators. :param filename: Path to the output Excel file. :type filename: str</p>"},{"location":"reference/#tfopt.local.objfn.minfn","title":"<code>tfopt.local.objfn.minfn</code>","text":""},{"location":"reference/#tfopt.local.objfn.minfn.objective_","title":"<code>objective_(x, expression_matrix, regulators, tf_protein_matrix, psite_tensor, n_reg, T_use, n_genes, beta_start_indices, num_psites, loss_type, lam1=1e-06, lam2=1e-06)</code>","text":"<p>Originally implemented by Julius Normann.</p> <p>This version has been modified and optimized for consistency &amp; speed in submodules by Abhinav Mishra.</p> <p>Computes a loss value using one of several loss functions.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code> </code> <p>Decision vector.</p> required <code>expression_matrix</code> <code> </code> <p>(n_genes x T_use) measured gene expression values.</p> required <code>regulators</code> <code> </code> <p>(n_genes x n_reg) indices of TF regulators for each gene.</p> required <code>tf_protein_matrix</code> <code> </code> <p>(n_TF x T_use) TF protein time series.</p> required <code>psite_tensor</code> <code> </code> <p>(n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros).</p> required <code>n_reg</code> <code> </code> <p>Maximum number of regulators per gene.</p> required <code>T_use</code> <code> </code> <p>Number of time points used.</p> required <code>n_genes,</code> <code>n_TF</code> <p>Number of genes and TF respectively.</p> required <code>beta_start_indices</code> <p>Integer array giving the starting index (in the \u03b2\u2013segment) for each TF.</p> required <code>num_psites</code> <code> </code> <p>Integer array with the actual number of PSites for each TF.</p> required <code>loss_type</code> <code> </code> <p>Integer indicating the loss type (0: MSE, 1: MAE, 2: soft L1, 3: Cauchy, 4: Arctan, 5: Elastic Net, 6: Tikhonov).</p> required <code>lam1,</code> <code>lam2</code> <p>Regularization parameters (used for loss_type 5 and 6).</p> required <p>Returns:</p> Type Description <p>The computed loss (a scalar).</p>"},{"location":"reference/#tfopt.local.objfn.minfn.compute_predictions","title":"<code>compute_predictions(x, regulators, tf_protein_matrix, psite_tensor, n_reg, T_use, n_genes, beta_start_indices, num_psites)</code>","text":"<p>Computes the predicted expression matrix based on the decision vector x. This function uses the regulators, TF protein matrix, and post-translational modification tensor to generate predictions for each gene at each time point. Parameters:   x                  : Decision vector.   regulators         : (n_genes x n_reg) indices of TF regulators for each gene.   tf_protein_matrix  : (n_TF x T_use) TF protein time series.   psite_tensor       : (n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros).   n_reg              : Maximum number of regulators per gene.   T_use              : Number of time points used.   n_genes, n_TF     : Number of genes and TF respectively.   beta_start_indices : Integer array giving the starting index (in the \u03b2\u2013segment) for each TF.   num_psites         : Integer array with the actual number of PSites for each TF. Returns:     predictions        : (n_genes x T_use) matrix of predicted gene expression values.</p>"},{"location":"reference/#tfopt.local.objfn.minfn.objective_wrapper","title":"<code>objective_wrapper(x, expression_matrix, regulators, tf_protein_matrix, psite_tensor, n_reg, T_use, n_genes, beta_start_indices, num_psites, loss_type)</code>","text":"<p>Wrapper function for the objective function. This function is used to call the objective function with the appropriate parameters. Parameters:   x                  : Decision vector.   expression_matrix  : (n_genes x T_use) measured gene expression values.   regulators         : (n_genes x n_reg) indices of TF regulators for each gene.   tf_protein_matrix  : (n_TF x T_use) TF protein time series.   psite_tensor       : (n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros).   n_reg              : Maximum number of regulators per gene.   T_use              : Number of time points used.   n_genes, n_TF     : Number of genes and TF respectively.   beta_start_indices : Integer array giving the starting index (in the \u03b2\u2013segment) for each TF.   num_psites         : Integer array with the actual number of PSites for each TF.   loss_type          : Integer indicating the loss type (0: MSE, 1: MAE, 2: soft L1, 3: Cauchy, 4: Arctan, 5: Elastic Net, 6: Tikhonov). Returns:     loss               : The computed loss (a scalar).</p>"},{"location":"reference/#tfopt.local.opt.optrun","title":"<code>tfopt.local.opt.optrun</code>","text":""},{"location":"reference/#tfopt.local.opt.optrun.run_optimizer","title":"<code>run_optimizer(x0, bounds, lin_cons, expression_matrix, regulators, tf_protein_matrix, psite_tensor, n_reg, T_use, n_genes, beta_start_indices, num_psites, loss_type)</code>","text":"<p>Runs the optimization algorithm to minimize the objective function.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code> </code> <p>Initial guess for the optimization variables.</p> required <code>bounds</code> <code> </code> <p>Bounds for the optimization variables.</p> required <code>lin_cons</code> <code> </code> <p>Linear constraints for the optimization problem.</p> required <code>expression_matrix</code> <code> </code> <p>(n_genes x T_use) measured gene expression values.</p> required <code>regulators</code> <code> </code> <p>(n_genes x n_reg) indices of TF regulators for each gene.</p> required <code>tf_protein_matrix</code> <code> </code> <p>(n_TF x T_use) TF protein time series.</p> required <code>psite_tensor</code> <code> </code> <p>(n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros).</p> required <code>n_reg</code> <code> </code> <p>Maximum number of regulators per gene.</p> required <code>T_use</code> <code> </code> <p>Number of time points used.</p> required <code>n_genes,</code> <code>n_TF</code> <p>Number of genes and TF respectively.</p> required <code>beta_start_indices</code> <code> </code> <p>Integer array giving the starting index (in the \u03b2\u2013segment) for each TF.</p> required <code>num_psites</code> <code> </code> <p>Integer array with the actual number of PSites for each TF.</p> required <code>loss_type</code> <code> </code> <p>Type of loss function to use.</p> required <p>Returns:     result             : Result of the optimization process, including the optimized parameters and objective value.</p>"},{"location":"reference/#tfopt.local.optcon.construct","title":"<code>tfopt.local.optcon.construct</code>","text":""},{"location":"reference/#tfopt.local.optcon.construct.build_fixed_arrays","title":"<code>build_fixed_arrays(gene_ids, expression_matrix, tf_ids, tf_protein, tf_psite_data, tf_psite_labels, reg_map)</code>","text":"<p>Builds fixed-shape arrays from the input data. Returns:   - expression_matrix: array of shape (n_genes, T)   - regulators: array of shape (n_genes, n_reg) with indices into tf_ids.   - tf_protein_matrix: array of shape (n_TF, T)   - psite_tensor: array of shape (n_TF, n_psite_max, T), padded with zeros.   - n_reg: maximum number of regulators per gene.   - n_psite_max: maximum number of PSites among TFs.   - psite_labels_arr: list (length n_TF) of lists of PSite names (padded with empty strings).   - num_psites: array of length n_TF with the actual number of PSites for each TF.</p>"},{"location":"reference/#tfopt.local.optcon.construct.constraint_alpha_func","title":"<code>constraint_alpha_func(x, n_genes, n_reg)</code>","text":"<p>For each gene, the sum of its alpha parameters must equal 1.</p>"},{"location":"reference/#tfopt.local.optcon.construct.constraint_beta_func","title":"<code>constraint_beta_func(x, n_alpha, n_TF, beta_start_indices, num_psites, no_psite_tf)</code>","text":"<p>For each TF, the sum of its beta parameters must equal 1.</p>"},{"location":"reference/#tfopt.local.optcon.construct.build_linear_constraints","title":"<code>build_linear_constraints(n_genes, n_TF, n_reg, n_alpha, beta_start_indices, num_psites, no_psite_tf)</code>","text":"<p>Build linear constraints for the optimization problem.</p> <p>The constraints are: 1. For each mRNA, the sum of its alpha parameters must equal 1. 2. For each TF, the sum of its beta parameters must equal 1.</p>"},{"location":"reference/#tfopt.local.optcon.filter","title":"<code>tfopt.local.optcon.filter</code>","text":""},{"location":"reference/#tfopt.local.optcon.filter.load_and_filter_data","title":"<code>load_and_filter_data()</code>","text":"<p>Load and filter data for the optimization problem. This function loads gene expression data, transcription factor (TF) data, and regulation data. It filters genes to only include those with at least one regulator and filters regulators to only include those present in the TF data. The function returns the filtered gene IDs, expression matrix, TF IDs, TF protein data, TF phosphorylation site data, TF phosphorylation site labels, and the regulation map. It raises a ValueError if no genes with regulators are found. The function also filters the TF data to only include those present in the regulation map.</p> <p>The function returns: - gene_ids: List of filtered gene IDs. - expr_matrix: Filtered expression matrix. - expr_time_cols: Time columns for gene expression data. - tf_ids: Filtered TF IDs. - tf_protein: Dictionary mapping TF IDs to their protein data. - tf_psite_data: Dictionary mapping TF IDs to their phosphorylation site data. - tf_psite_labels: Dictionary mapping TF IDs to their phosphorylation site labels. - tf_time_cols: Time columns for TF data. - reg_map: Regulation map, mapping gene IDs to their regulators.</p>"},{"location":"reference/#tfopt.local.optcon.filter.prepare_data","title":"<code>prepare_data(gene_ids, expr_matrix, tf_ids, tf_protein, tf_psite_data, tf_psite_labels, tf_time_cols, reg_map)</code>","text":"<p>Prepares the data for optimization by filtering the expression matrix to match the number of time points and building fixed arrays.</p> <p>Parameters:</p> Name Type Description Default <code>gene_ids</code> <code>list</code> <p>List of gene IDs.</p> required <code>expr_matrix</code> <code>ndarray</code> <p>Gene expression matrix.</p> required <code>tf_ids</code> <code>list</code> <p>List of transcription factor IDs.</p> required <code>tf_protein</code> <code>dict</code> <p>Dictionary mapping TF IDs to their protein data.</p> required <code>tf_psite_data</code> <code>dict</code> <p>Dictionary mapping TF IDs to their phosphorylation site data.</p> required <code>tf_psite_labels</code> <code>dict</code> <p>Dictionary mapping TF IDs to their phosphorylation site labels.</p> required <code>tf_time_cols</code> <code>list</code> <p>Time columns for TF data.</p> required <code>reg_map</code> <code>dict</code> <p>Regulation map, mapping gene IDs to their regulators.</p> required <p>Returns:     fixed_arrays (tuple): Tuple containing the fixed arrays:         - expression_matrix: array of shape (n_genes, T)         - regulators: array of shape (n_genes, n_reg) with indices into tf_ids.         - tf_protein_matrix: array of shape (n_TF, T)         - psite_tensor: array of shape (n_TF, n_psite_max, T), padded with zeros.         - n_reg: maximum number of regulators per gene.         - n_psite_max: maximum number of PSites among TFs.         - psite_labels_arr: list (length n_TF) of lists of PSite names (padded with empty strings).         - num_psites: array of length n_TF with the actual number of PSites for each TF.     T_use (int): Number of time points used in the expression matrix.</p>"},{"location":"reference/#tfopt.local.utils.iodata","title":"<code>tfopt.local.utils.iodata</code>","text":""},{"location":"reference/#tfopt.local.utils.iodata.min_max_normalize","title":"<code>min_max_normalize(df, custom_max=None)</code>","text":"<p>Row-wise (per-sample) min-max normalize time-series columns starting with 'x'.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Input DataFrame with time-series columns (x1-xN).</p> required <code>custom_max</code> <code>float</code> <p>If given, used as max for all rows.</p> <code>None</code> <p>Returns:</p> Type Description <p>pd.DataFrame: Normalized DataFrame with same shape.</p>"},{"location":"reference/#tfopt.local.utils.iodata.load_expression_data","title":"<code>load_expression_data(filename=INPUT3)</code>","text":"<p>Loads gene expression (mRNA) data. Expects a CSV with a 'GeneID' column and time-point columns.</p>"},{"location":"reference/#tfopt.local.utils.iodata.load_tf_protein_data","title":"<code>load_tf_protein_data(filename=INPUT1)</code>","text":"<p>Loads TF protein data along with PSite information. Expects a CSV with 'GeneID' and 'Psite' columns. For rows without a valid PSite, the entire row is considered as the protein signal.</p>"},{"location":"reference/#tfopt.local.utils.iodata.load_regulation","title":"<code>load_regulation(filename=INPUT4)</code>","text":"Assumes the regulation file is reversed <ul> <li>The 'Source' column holds gene (mRNA) identifiers.</li> <li>The 'Target' column holds TF identifiers.</li> </ul> <p>Returns a mapping from gene (source) to a list of TFs (targets).</p>"},{"location":"reference/#tfopt.local.utils.iodata.summarize_stats","title":"<code>summarize_stats(input3=INPUT3, input1=INPUT1, input4=INPUT4)</code>","text":"<p>Summarizes statistics for the expression data (input3) and TF protein data (input1). It also summarizes the data after filtering based on the mapping file (input4).</p> The function prints the following statistics <ul> <li>Global min, max, std, var for the full dataset.</li> <li>Time-wise min, max, std, var for each time point.</li> <li>Global min, max, std, var for the subset data (filtered by input4).</li> <li>Time-wise min, max, std, var for the subset data.</li> </ul> <p>Args:     input3 (str): Path to the expression data CSV file.     input1 (str): Path to the TF protein data CSV file.     input4 (str): Path to the mapping file CSV.</p>"},{"location":"reference/#tfopt.local.utils.iodata.create_report","title":"<code>create_report(results_dir: str, output_file: str = 'report.html')</code>","text":"<p>Creates a single global report HTML file from all gene folders inside the results directory.</p> <p>For each gene folder (e.g. \"ABL2\"), the report will include:   - All PNG plots and interactive HTML plots displayed in a grid with three plots per row.   - Each plot is confined to a fixed size of 900px by 900px.   - Data tables from XLSX or CSV files in the gene folder are displayed below the plots, one per row.</p> <p>Parameters:</p> Name Type Description Default <code>results_dir</code> <code>str</code> <p>Path to the root results directory.</p> required <code>output_file</code> <code>str</code> <p>Name of the generated global report file (placed inside results_dir).</p> <code>'report.html'</code>"},{"location":"reference/#tfopt.local.utils.params","title":"<code>tfopt.local.utils.params</code>","text":""},{"location":"reference/#tfopt.local.utils.params.get_optimization_parameters","title":"<code>get_optimization_parameters(expression_matrix, tf_protein_matrix, n_reg, T_use, psite_labels_arr, num_psites, lb, ub)</code>","text":"<p>Prepare the optimization parameters for the optimization problem. This function initializes the alpha and beta parameters, sets up the bounds, and constructs the linear constraints for the optimization problem. It returns the initial guess for the optimization variables, the number of alpha parameters, the starting indices for beta parameters, the bounds, the boolean array indicating TFs without phosphorylation sites, and the number of genes and TFs.</p> <p>Parameters: expression_matrix (np.ndarray): Gene expression matrix. tf_protein_matrix (np.ndarray): TF protein matrix. n_reg (int): Number of regulators. T_use (int): Number of time points used in the expression matrix. psite_labels_arr (list): List of lists containing phosphorylation site labels. num_psites (np.ndarray): Array containing the number of phosphorylation sites for each TF. lb (float): Lower bound for beta parameters. ub (float): Upper bound for beta parameters.</p> <p>Returns: x0 (np.ndarray): Initial guess for the optimization variables. n_alpha (int): Number of alpha parameters. beta_start_indices (np.ndarray): Starting indices for beta parameters. bounds (list): List of tuples specifying the bounds for each optimization variable. no_psite_tf (np.ndarray): Boolean array indicating TFs without phosphorylation sites. n_genes (int): Number of genes. n_TF (int): Number of TFs. num_psites (np.ndarray): Array containing the number of phosphorylation sites for each TF. lin_cons (LinearConstraint): Linear constraints for the optimization problem. T_use (int): Number of time points used in the expression matrix.</p>"},{"location":"reference/#tfopt.local.utils.params.postprocess_results","title":"<code>postprocess_results(result, n_alpha, n_genes, n_reg, beta_start_indices, num_psites, reg_map, gene_ids, tf_ids, psite_labels_arr)</code>","text":"<p>Post-process the optimization results to extract the final alpha and beta parameters. This function reshapes the optimization result into the final alpha and beta matrices, and builds the mapping of TFs to mRNAs and phosphorylation sites. It also logs the mappings for debugging purposes.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>OptimizeResult</code> <p>The result of the optimization.</p> required <code>n_alpha</code> <code>int</code> <p>Number of alpha parameters.</p> required <code>n_genes</code> <code>int</code> <p>Number of genes.</p> required <code>n_reg</code> <code>int</code> <p>Number of regulators.</p> required <code>beta_start_indices</code> <code>ndarray</code> <p>Starting indices for beta parameters.</p> required <code>num_psites</code> <code>ndarray</code> <p>Array containing the number of phosphorylation sites for each TF.</p> required <code>reg_map</code> <code>dict</code> <p>Regulation map, mapping gene IDs to their regulators.</p> required <code>gene_ids</code> <code>list</code> <p>List of gene IDs.</p> required <code>tf_ids</code> <code>list</code> <p>List of transcription factor IDs.</p> required <code>psite_labels_arr</code> <code>list</code> <p>List of lists containing phosphorylation site labels.</p> required <p>Returns:</p> Name Type Description <code>final_x</code> <code>ndarray</code> <p>Final optimization result.</p> <code>final_alpha</code> <code>ndarray</code> <p>Final alpha parameters reshaped into a matrix.</p> <code>final_beta</code> <code>ndarray</code> <p>Final beta parameters reshaped into a matrix.</p>"},{"location":"reference/#fitting-analysis","title":"Fitting Analysis","text":""},{"location":"reference/#tfopt.fitanalysis.helper","title":"<code>tfopt.fitanalysis.helper</code>","text":""},{"location":"reference/#tfopt.fitanalysis.helper.Plotter","title":"<code>Plotter</code>","text":"<p>A class to plot various analysis results from an Excel file. The class provides methods to visualize the alpha and beta values, residuals, observed and estimated values, and other metrics.</p> <p>The plots include: - Alpha distribution - Beta bar plots - Heatmap of absolute residuals - Goodness of fit - Kullback-Leibler divergence - PCA - Box plots for alpha and beta values - CDF for alpha and beta values - Time-wise residuals</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.__init__","title":"<code>__init__(filepath, savepath)</code>","text":"<p>Initializes the Plotter instance by loading data from the Excel file.</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.load_data","title":"<code>load_data()</code>","text":"<p>Loads data from the specified Excel file. The data includes residuals, observed values, estimated values, alpha values, and beta values.</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.plot_alpha_distribution","title":"<code>plot_alpha_distribution()</code>","text":"<p>Plots the distribution of alpha parameter values grouped by transcription factors (TFs) using a strip plot.</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.plot_beta_barplots","title":"<code>plot_beta_barplots()</code>","text":"<p>Processes the beta values DataFrame and creates a separate bar plot for each unique transcription factor (TF).</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.plot_heatmap_abs_residuals","title":"<code>plot_heatmap_abs_residuals()</code>","text":"<p>Plots a heatmap of the absolute values of the residuals.</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.plot_goodness_of_fit","title":"<code>plot_goodness_of_fit()</code>","text":"<p>Creates a scatter plot comparing observed vs. estimated values, fits a linear regression model, plots the 95% confidence interval, and labels points outside the confidence interval.</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.plot_kld","title":"<code>plot_kld()</code>","text":"<p>Plots the Kullback-Leibler Divergence (KLD) for each mRNA. The KLD is calculated between the observed and estimated distributions of the mRNA expression levels.</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.plot_pca","title":"<code>plot_pca()</code>","text":"<p>Plots a PCA (Principal Component Analysis) of the observed and estimated values.</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.plot_boxplot_alpha","title":"<code>plot_boxplot_alpha()</code>","text":"<p>Plots a boxplot of the alpha values.</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.plot_boxplot_beta","title":"<code>plot_boxplot_beta()</code>","text":"<p>Plots a boxplot of the beta values.</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.plot_cdf_alpha","title":"<code>plot_cdf_alpha()</code>","text":"<p>Plots the cumulative distribution function (CDF) of the alpha values.</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.plot_cdf_beta","title":"<code>plot_cdf_beta()</code>","text":"<p>Plots the cumulative distribution function (CDF) of the beta values.</p>"},{"location":"reference/#tfopt.fitanalysis.helper.Plotter.plot_time_wise_residuals","title":"<code>plot_time_wise_residuals()</code>","text":"<p>Plots the residuals over time for each mRNA.</p>"},{"location":"reference/#ode-modelling-parameter-estimation","title":"ODE Modelling &amp; Parameter Estimation","text":""},{"location":"reference/#cli-entry-point","title":"CLI Entry Point","text":""},{"location":"reference/#bin.main","title":"<code>bin.main</code>","text":""},{"location":"reference/#bin.main.main","title":"<code>main()</code>","text":"<p>Main function to run the phosphorylation modelling process. It reads the configuration, loads the data, and processes each gene in parallel. It also handles logging and output organization.</p>"},{"location":"reference/#configuration","title":"Configuration","text":""},{"location":"reference/#config.config","title":"<code>config.config</code>","text":""},{"location":"reference/#config.config.parse_bound_pair","title":"<code>parse_bound_pair(val)</code>","text":"<p>Parse a string representing a pair of bounds (lower, upper) into a tuple of floats. The upper bound can be 'inf' or 'infinity' to represent infinity. Raises ValueError if the input is not in the correct format. Args:     val (str): The string to parse, e.g., \"0,3\" or \"0,infinity\". Returns:     tuple: A tuple containing the lower and upper bounds as floats.</p>"},{"location":"reference/#config.config.parse_fix_value","title":"<code>parse_fix_value(val)</code>","text":"<p>Parse a fixed value or a list of fixed values from a string. If the input is a single value, it returns that value as a float. If the input is a comma-separated list, it returns a list of floats. Raises ValueError if the input is not in the correct format. Args:     val (str): The string to parse, e.g., \"1.0\" or \"1.0,2.0\". Returns:     float or list: The parsed fixed value(s) as a float or a list of floats.</p>"},{"location":"reference/#config.config.ensure_output_directory","title":"<code>ensure_output_directory(directory)</code>","text":"<p>:param directory: :type directory: str</p>"},{"location":"reference/#config.config.parse_args","title":"<code>parse_args()</code>","text":"<p>Parse command-line arguments for the PhosKinTime script. This function uses argparse to define and handle the command-line options. It includes options for setting bounds, fixed parameters, bootstrapping, profile estimation, and input file paths. The function returns the parsed arguments as a Namespace object. The arguments include:     --A-bound: Bounds for parameter A (default: \"0,3\")     --B-bound: Bounds for parameter B (default: \"0,3\")     --C-bound: Bounds for parameter C (default: \"0,3\")     --D-bound: Bounds for parameter D (default: \"0,3\")     --Ssite-bound: Bounds for Ssite (default: \"0,3\")     --Dsite-bound: Bounds for Dsite (default: \"0,3\")     --fix-A: Fixed value for parameter A     --fix-B: Fixed value for parameter B     --fix-C: Fixed value for parameter C     --fix-D: Fixed value for parameter D     --fix-Ssite: Fixed value for Ssite     --fix-Dsite: Fixed value for Dsite     --fix-t: JSON string mapping time points to fixed param values     --bootstraps: Number of bootstrapping iterations (default: 0)     --profile-start: Start time for profile estimation (default: None)     --profile-end: End time for profile estimation (default: 1)     --profile-step: Step size for profile estimation (default: 0.5)     --input-excel: Path to the input Excel file (default: INPUT_EXCEL) Returns:     argparse.Namespace: The parsed command-line arguments.</p>"},{"location":"reference/#config.config.log_config","title":"<code>log_config(logger, bounds, fixed_params, time_fixed, args)</code>","text":"<p>Log the configuration settings for the PhosKinTime script. This function logs the parameter bounds, fixed parameters, bootstrapping iterations, time-specific fixed parameters, and profile estimation settings. It uses the provided logger to output the information. :param logger: :param bounds: :param fixed_params: :param time_fixed: :param args: :return:</p>"},{"location":"reference/#config.config.extract_config","title":"<code>extract_config(args)</code>","text":"<p>Extract configuration settings from command-line arguments. This function creates a dictionary containing the parameter bounds, fixed parameters, bootstrapping iterations, time-specific fixed parameters, and profile estimation settings. It also sets the maximum number of workers for parallel processing. The function returns the configuration dictionary. :param args: :return:</p>"},{"location":"reference/#config.config.score_fit","title":"<code>score_fit(gene, params, weight, target, prediction, alpha=ALPHA_WEIGHT, beta=BETA_WEIGHT, gamma=GAMMA_WEIGHT, delta=DELTA_WEIGHT, mu=MU_WEIGHT)</code>","text":"<p>Calculate the score for the fit of a model to target data. The score is a weighted combination of various metrics including mean squared error (MSE), root mean squared error (RMSE), mean absolute error (MAE), variance, and regularization penalty. The weights for each metric can be adjusted using the parameters alpha, beta, gamma, and delta. The regularization penalty is controlled by the reg_penalty parameter. The function returns the calculated score. :param target: :param prediction: :param params: :param alpha: :param beta: :param gamma: :param delta: :param reg_penalty: :return:</p>"},{"location":"reference/#config.constants","title":"<code>config.constants</code>","text":""},{"location":"reference/#config.constants.get_param_names_rand","title":"<code>get_param_names_rand(num_psites: int) -&gt; list</code>","text":"<p>Generate parameter names for the random model. Format: ['A', 'B', 'C', 'D'] +         ['S1', 'S2', ..., 'S'] +         [parameter names for all combinations of dephosphorylation sites]."},{"location":"reference/#config.constants.get_param_names_ds","title":"<code>get_param_names_ds(num_psites: int) -&gt; list</code>","text":"<p>Generate parameter names for distributive or successive models. Format: ['A', 'B', 'C', 'D'] +         ['S1', 'S2', ..., 'S'] +         ['D1', 'D2', ..., 'D']."},{"location":"reference/#config.constants.generate_labels_rand","title":"<code>generate_labels_rand(num_psites: int) -&gt; list</code>","text":"<p>Generates labels for the states based on the number of phosphorylation sites for the random model. Returns a list with the base labels \"R\" and \"P\", followed by labels for all combinations of phosphorylated sites. Example for num_psites=2: [\"R\", \"P\", \"P1\", \"P2\", \"P12\"]</p>"},{"location":"reference/#config.constants.generate_labels_ds","title":"<code>generate_labels_ds(num_psites: int) -&gt; list</code>","text":"<p>Generates labels for the states based on the number of phosphorylation sites for the distributive or successive models. Returns a list with the base labels \"R\" and \"P\", followed by labels for each individual phosphorylated state. Example for num_psites=2: [\"R\", \"P\", \"P1\", \"P2\"]</p>"},{"location":"reference/#config.constants.location","title":"<code>location(path: str, label: str = None) -&gt; str</code>","text":"<p>Returns a clickable hyperlink string for supported terminals using ANSI escape sequences.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path or URL.</p> required <code>label</code> <code>str</code> <p>The display text for the link. Defaults to the path if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string that, when printed, shows a clickable link in terminals that support ANSI hyperlinks.</p>"},{"location":"reference/#config.constants.get_number_of_params_rand","title":"<code>get_number_of_params_rand(num_psites)</code>","text":"<p>Calculate the number of parameters required for the ODE system based on the number of phosphorylation sites.</p> <p>Parameters:</p> Name Type Description Default <code>num_psites</code> <code>int</code> <p>Number of phosphorylation sites (1 to 4).</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Total number of parameters.</p>"},{"location":"reference/#config.constants.get_bounds_rand","title":"<code>get_bounds_rand(num_psites, ub=0, lower=0)</code>","text":"<p>Generate bounds for the ODE parameters based on the number of phosphorylation sites.</p> <p>Parameters:</p> Name Type Description Default <code>num_psites</code> <code>int</code> <p>Number of phosphorylation sites.</p> required <code>lower</code> <code>float</code> <p>Lower bound for parameters.</p> <code>0</code> <code>upper</code> <code>float</code> <p>Upper bound for parameters.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of bounds as [lower, upper] for each parameter.</p>"},{"location":"reference/#config.logconf","title":"<code>config.logconf</code>","text":""},{"location":"reference/#config.logconf.ColoredFormatter","title":"<code>ColoredFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>Custom formatter to add colors to log messages and elapsed time. This formatter uses ANSI escape codes to colorize the log messages based on their severity level. It also includes a right-aligned clock that shows the elapsed time since the logger was initialized. The elapsed time is displayed in a human-readable format (e.g., \"1h 23m 45s\"). The formatter is designed to be used with a logger that has a console handler. The elapsed time is calculated from the time the logger was initialized and is displayed in a right-aligned format. The formatter also ensures that the log messages are padded to a specified width, which can be adjusted using the <code>width</code> parameter. The <code>remove_ansi</code> method is used to strip ANSI escape codes from the log message for accurate padding calculation. The <code>format</code> method is overridden to customize the log message format, including the timestamp, logger name, log level, and message. The <code>setup_logger</code> function is used to configure the logger with a file handler and a stream handler. The file handler writes log messages to a specified log file, while the stream handler outputs log messages to the console. The logger is set to the specified logging level, and the log file is created in the specified directory. The log file is rotated based on size, and old log files are backed up.</p>"},{"location":"reference/#config.logconf.ColoredFormatter.format","title":"<code>format(record)</code>","text":"<p>Format the log record with colors and elapsed time. This method overrides the default format method to customize the log message format. It includes the timestamp, logger name, log level, and message.</p>"},{"location":"reference/#config.logconf.ColoredFormatter.remove_ansi","title":"<code>remove_ansi(s)</code>  <code>staticmethod</code>","text":"<p>Remove ANSI escape codes from a string.</p>"},{"location":"reference/#config.logconf.setup_logger","title":"<code>setup_logger(name='phoskintime', log_file=None, level=logging.DEBUG, log_dir=LOG_DIR, rotate=True, max_bytes=2 * 1024 * 1024, backup_count=5)</code>","text":"<p>Setup a logger with colored output and file logging. This function creates a logger with colored output for console messages :param name: :param log_file: :param level: :param log_dir: :param rotate: :param max_bytes: :param backup_count: :return: logger</p>"},{"location":"reference/#core-functions","title":"Core Functions","text":""},{"location":"reference/#paramest.normest","title":"<code>paramest.normest</code>","text":""},{"location":"reference/#paramest.normest.worker_find_lambda","title":"<code>worker_find_lambda(lam: float, gene: str, target: np.ndarray, p0: np.ndarray, time_points: np.ndarray, free_bounds: Tuple[np.ndarray, np.ndarray], init_cond: np.ndarray, num_psites: int, p_data: np.ndarray) -&gt; Tuple[float, float, str]</code>","text":"<p>Worker function for a single lambda value.</p>"},{"location":"reference/#paramest.normest.find_best_lambda","title":"<code>find_best_lambda(gene: str, target: np.ndarray, p0: np.ndarray, time_points: np.ndarray, free_bounds: Tuple[np.ndarray, np.ndarray], init_cond: np.ndarray, num_psites: int, p_data: np.ndarray, lambdas=np.linspace(0.001, 1, 10), max_workers: int = os.cpu_count()) -&gt; Tuple[float, str]</code>","text":"<p>Finds best lambda_reg to use in model_func.</p>"},{"location":"reference/#paramest.normest.normest","title":"<code>normest(gene, p_data, r_data, init_cond, num_psites, time_points, bounds, bootstraps, use_regularization=USE_REGULARIZATION)</code>","text":"<p>Perform normal parameter estimation using all provided time points at once. Uses the provided bounds and supports bootstrapping if specified.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>p_data</code> <p>Measurement data (DataFrame or numpy array). Assumes data starts at column index 2.</p> required <code>-</code> <code>r_data</code> <p>mRNA data (DataFrame or numpy array). Assumes data starts at column index 1.</p> required <code>-</code> <code>init_cond</code> <p>Initial condition for the ODE solver.</p> required <code>-</code> <code>num_psites</code> <p>Number of phosphorylation sites.</p> required <code>-</code> <code>time_points</code> <p>Array of time points to use.</p> required <code>-</code> <code>bounds</code> <p>Dictionary of parameter bounds.</p> required <code>-</code> <code>bootstraps</code> <p>Number of bootstrapping iterations.</p> required <code>-</code> <code>use_regularization</code> <p>Flag to apply Tikhonov regularization.</p> required <code>-</code> <code>lambda_reg</code> <p>Regularization strength.</p> required <p>Returns:</p> Type Description <ul> <li>est_params: List with the full estimated parameter vector.</li> </ul> <ul> <li>model_fits: List with the ODE solution and model predictions.</li> </ul> <ul> <li>error_vals: List with the squared error (data vs. model prediction).</li> </ul>"},{"location":"reference/#paramest.toggle","title":"<code>paramest.toggle</code>","text":""},{"location":"reference/#paramest.toggle.estimate_parameters","title":"<code>estimate_parameters(gene, p_data, r_data, init_cond, num_psites, time_points, bounds, bootstraps)</code>","text":"<p>This function allows for the selection of the estimation mode and handles the parameter estimation process accordingly.</p> <p>It uses the sequential estimation method for \"sequential\" mode (deprecated) and the normal estimation method for \"normal\" mode.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>gene</code> <p>The gene name.</p> required <code>-</code> <code>p_data</code> <p>phosphorylation data (DataFrame or numpy array).</p> required <code>-</code> <code>r_data</code> <p>mRNA data (DataFrame or numpy array).</p> required <code>-</code> <code>init_cond</code> <p>Initial condition for the ODE solver.</p> required <code>-</code> <code>num_psites</code> <p>Number of phosphorylation sites.</p> required <code>-</code> <code>time_points</code> <p>Array of time points to use.</p> required <code>-</code> <code>bounds</code> <p>Dictionary of parameter bounds.</p> required <code>-</code> <code>fixed_params</code> <p>Dictionary of fixed parameters.</p> required <code>-</code> <code>bootstraps</code> <p>Number of bootstrapping iterations (only used in normal mode).</p> required <p>:returns:     - model_fits: List with the ODE solution and model predictions.     - estimated_params: List with the full estimated parameter vector.     - seq_model_fit: Sequential model fit for the gene.     - errors: Error metrics (MSE, MAE).</p>"},{"location":"reference/#weights-for-curve-fitting","title":"Weights for Curve Fitting","text":""},{"location":"reference/#models.weights","title":"<code>models.weights</code>","text":""},{"location":"reference/#models.weights.early_emphasis","title":"<code>early_emphasis(p_data, time_points, num_psites)</code>","text":"<p>Function that calculates custom weights for early time points in a dataset. The weights are based on the data values and the time differences between points.</p> <p>The weights are calculated in a way that emphasizes early time points, while also considering the data values and time intervals.</p> <p>:param p_data: :param time_points: :param num_psites: :return: flattened array of custom weights</p>"},{"location":"reference/#models.weights.get_protein_weights","title":"<code>get_protein_weights(gene, input1_path=Path(__file__).resolve().parent.parent / 'processing' / 'input1_wstd.csv', input2_path=Path(__file__).resolve().parent.parent / 'kinopt' / 'data' / 'input2.csv')</code>","text":"<p>Extracts x1_std to x14_std weights for a single GeneID.</p> <p>Parameters:</p> Name Type Description Default <code>gene</code> <p>GeneID (str) to process</p> required <code>input1_path</code> <p>Path to input1_wstd.csv</p> <code>parent / 'processing' / 'input1_wstd.csv'</code> <code>input2_path</code> <p>Path to input2.csv</p> <code>parent / 'kinopt' / 'data' / 'input2.csv'</code> <p>Returns:</p> Type Description <p>Flattened numpy array of weights for the specific GeneID</p>"},{"location":"reference/#models.weights.get_weight_options","title":"<code>get_weight_options(target, t_target, num_psites, use_regularization, reg_len, early_weights, ms_gauss_weights)</code>","text":"<p>Function to calculate weights for parameter estimation based on the target data and time points. The weights are designed to emphasize early time points and account for noise in the data. The function also includes options for regularization and custom early point emphasis.</p> <p>The following are the weighting schemes: - Inverse data: 1 / abs(target) - Exponential decay: exp(-0.5 * target) - Log scale: 1 / log(1 + abs(target)) - Time difference: 1 / abs(time_diff) - Moving average: 1 / abs(target - moving_avg) - Sigmoid time decay: 1 / (1 + exp(time_indices - 5)) - Exponential early emphasis: exp(-0.5 * time_indices) - Polynomial decay: 1 / (1 + 0.5 * time_indices) - MS SNR model: 1 / sqrt(signal) - MS inverse variance: 1 / (abs(target) ** 0.7) - Flat region penalty: 1 / abs(grad) - Steady state decay: exp(-0.1 * time_indices) - Inverse sqrt data: 1 / sqrt(abs(target)) - Early emphasis moderate: ones - Early emphasis steep decay: ones - Custom early points emphasis: early_weights</p> <p>:param target: :param t_target: :param num_psites: :param use_regularization: :param reg_len: :param early_weights: :return: dictionary of weights for parameter estimation</p>"},{"location":"reference/#parameter-estimation","title":"Parameter Estimation","text":""},{"location":"reference/#paramest.core","title":"<code>paramest.core</code>","text":""},{"location":"reference/#paramest.core.process_gene","title":"<code>process_gene(gene, kinase_data, mrna_data, time_points, bounds, fixed_params, desired_times=None, time_fixed=None, bootstraps=0, out_dir=OUT_DIR)</code>","text":"<p>Process a single gene by estimating its parameters and generating plots. This function extracts gene-specific data, estimates parameters using the specified estimation mode, and generates plots for the estimated parameters and the model fits. It also calculates error metrics and saves the results to Excel files.</p> <p>:param gene: :param kinase_data: :param mrna_data: :param time_points: :param bounds: :param fixed_params: :param desired_times: :param time_fixed: :param bootstraps: :param out_dir: :return:     - gene: The gene being processed.     - estimated_params: Estimated parameters for the gene.     - model_fits: Model fits for the gene.     - seq_model_fit: Sequential model fit for the gene.     - errors: Error metrics (MSE, MAE).     - final_params: Final estimated parameters.     - profiles: Adaptive profile estimates (if applicable).     - profiles_df: DataFrame of adaptive profile estimates (if applicable).     - param_df: DataFrame of estimated parameters.     - gene_psite_data: Dictionary of gene-specific data.</p>"},{"location":"reference/#paramest.core.process_gene_wrapper","title":"<code>process_gene_wrapper(gene, kinase_data, mrna_data, time_points, bounds, fixed_params, desired_times, time_fixed, bootstraps, out_dir=OUT_DIR)</code>","text":"<p>Wrapper function to process a gene. This function is a placeholder for any additional processing or modifications needed before calling the main processing function.</p> <p>:param gene: :param kinase_data: :param mrna_data: :param time_points: :param bounds: :param fixed_params: :param desired_times: :param time_fixed: :param bootstraps: :param out_dir: :return:     - result: Dictionary containing the results of the gene processing.</p>"},{"location":"reference/#confidence-intervals-using-linearization","title":"Confidence Intervals using Linearization","text":""},{"location":"reference/#paramest.identifiability.ci","title":"<code>paramest.identifiability.ci</code>","text":""},{"location":"reference/#paramest.identifiability.ci.confidence_intervals","title":"<code>confidence_intervals(gene, popt, pcov, target, model, alpha_val=0.05)</code>","text":"<p>Computes the confidence intervals for parameter estimates using a linearization approach.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>popt</code> <p>1D numpy array of best-fit parameter estimates.</p> required <code>-</code> <code>pcov</code> <p>Square covariance matrix (numpy array) corresponding to popt.</p> required <code>-</code> <code>target</code> <p>1D numpy array of observed data (used to compute degrees of freedom).</p> required <code>-</code> <code>alpha_val</code> <p>Significance level (default 0.05 for a 95% confidence interval).</p> required <p>Returns:</p> Type Description <p>A dictionary with the following keys: 'beta_hat': Best-fit parameter estimates. 'se_lin': Standard errors (sqrt of diagonal of pcov). 'df_lin': Degrees of freedom (n_obs - n_params). 't_stat': t-statistics for each parameter. 'pval': Two-sided p-values for each parameter. 'qt_lin': t critical value for the given alpha and degrees of freedom. 'lwr_ci': Lower 95% confidence intervals. 'upr_ci': Upper 95% confidence intervals.</p>"},{"location":"reference/#knockout-analysis","title":"Knockout Analysis","text":""},{"location":"reference/#knockout.helper","title":"<code>knockout.helper</code>","text":""},{"location":"reference/#perturbation-parameter-sensitivity-analysis","title":"Perturbation &amp; Parameter Sensitivity Analysis","text":""},{"location":"reference/#sensitivity.analysis","title":"<code>sensitivity.analysis</code>","text":""},{"location":"reference/#sensitivity.analysis.compute_bound","title":"<code>compute_bound(value, perturbation=PERTURBATIONS_VALUE)</code>","text":"<p>Computes the lower and upper bounds for a given parameter value. The bounds are computed as a percentage of the parameter value, with a specified perturbation value. The lower bound is capped at 0.0 to avoid negative values. The function returns a list containing the lower and upper bounds. :param perturbation: Fractional perturbation around the parameter value. :param value: The parameter value for which to compute the bounds. :return: A list containing the lower and upper bounds.</p>"},{"location":"reference/#sensitivity.analysis.define_sensitivity_problem_rand","title":"<code>define_sensitivity_problem_rand(num_psites, values)</code>","text":"<p>Defines the Morris sensitivity analysis problem for the random model.</p>"},{"location":"reference/#sensitivity.analysis.define_sensitivity_problem_ds","title":"<code>define_sensitivity_problem_ds(num_psites, values)</code>","text":"<p>Defines the Morris sensitivity analysis problem for the dynamic-site model.</p>"},{"location":"reference/#model-diagram","title":"Model Diagram","text":""},{"location":"reference/#models.diagram.helpers","title":"<code>models.diagram.helpers</code>","text":""},{"location":"reference/#models.diagram.helpers.powerset","title":"<code>powerset(iterable)</code>","text":"<p>Return the list of all subsets (as frozensets) of the given iterable. For example, for [1,2] returns:   [frozenset(), frozenset({1}), frozenset({2}), frozenset({1,2})]</p>"},{"location":"reference/#models.diagram.helpers.state_label","title":"<code>state_label(state)</code>","text":"<p>Convert a set of phosphorylation sites into a node label. The unphosphorylated state (empty set) is labeled \"P\". For nonempty states the label is \"P\" concatenated with the sorted site numbers.</p>"},{"location":"reference/#models.diagram.helpers.create_random_diagram","title":"<code>create_random_diagram(x, num_sites, output_filename)</code>","text":"<p>Create a random phosphorylation diagram. The diagram displays mRNA production/degradation, protein production, phosphorylation transitions (addition) and dephosphorylation transitions, as well as degradation edges for each state.</p>"},{"location":"reference/#models.diagram.helpers.create_distributive_diagram","title":"<code>create_distributive_diagram(x, num_sites, output_filename)</code>","text":"<p>Create a distributive phosphorylation diagram. This model shows single-step phosphorylation and dephosphorylation transitions for each site, along with production/degradation edges.</p>"},{"location":"reference/#models.diagram.helpers.create_successive_model","title":"<code>create_successive_model(x, num_sites, output_filename)</code>","text":"<p>Create a successive phosphorylation diagram. In this model, phosphorylation occurs in a sequential order from P to P1 to P2, etc., with corresponding dephosphorylation and degradation transitions.</p>"},{"location":"reference/#model-types","title":"Model Types","text":""},{"location":"reference/#models.distmod","title":"<code>models.distmod</code>","text":""},{"location":"reference/#models.distmod.ode_core","title":"<code>ode_core(y, A, B, C, D, S_rates, D_rates)</code>","text":"<p>The core ODE system for the distributive phosphorylation model.</p> <p>The system is defined by the following equations:</p> <p>dR/dt = A - B * R dP/dt = C * R - (D + sum(S_rates)) * P + sum(P_sites) dP_sites[i]/dt = S_rates[i] * P - (1.0 + D_rates[i]) * P_sites[i]</p> <p>where:</p> <p>R: the concentration of the mRNA P: the concentration of the protein P_sites: the concentration of the phosphorylated sites A: the rate of production of the mRNA B: the rate of degradation of the mRNA C: the rate of production of the protein D: the rate of degradation of the protein S_rates: the rates of phosphorylation of each site D_rates: the rates of dephosphorylation of each site</p> <p>:param y: :param A: :param B: :param C: :param D: :param S_rates: :param D_rates: :return: Derivative of y</p>"},{"location":"reference/#models.distmod.ode_system","title":"<code>ode_system(y, t, params, num_psites)</code>","text":"<p>The ODE system for the distributive phosphorylation model which calls the core ODE system.</p> <p>:param y: :param t: :param params: :param num_psites: :return: ode_core(y, A, B, C, D, S_rates, D_rates)</p>"},{"location":"reference/#models.distmod.solve_ode","title":"<code>solve_ode(params, init_cond, num_psites, t)</code>","text":"<p>Solve the ODE system for the distributive phosphorylation model.</p> <p>:param params: :param init_cond: :param num_psites: :param t: :return: solution of the ODE system, solution of phosphorylated sites</p>"},{"location":"reference/#models.randmod","title":"<code>models.randmod</code>","text":""},{"location":"reference/#models.randmod.ode_system","title":"<code>ode_system(y, t, A, B, C, D, num_sites, *params)</code>","text":"<p>The ODE system for the Random ODE model. The system is defined by the following equations: dR/dt = A - B * R dP/dt = C * R - D * P dX_j/dt = S_j * P - Ddeg_j * X_j where: R: the concentration of the mRNA P: the concentration of the protein X_j: the concentration of the phosphorylated state j A: the rate of production of the mRNA B: the rate of degradation of the mRNA C: the rate of production of the protein D: the rate of degradation of the protein S_j: the rate of phosphorylation of site j Ddeg_j: the rate of degradation of state j</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>array</code> <p>Current state of the system.</p> required <code>t</code> <code>float</code> <p>Current time.</p> required <code>A</code> <code>float</code> <p>Rate of production of the mRNA.</p> required <code>B</code> <code>float</code> <p>Rate of degradation of the mRNA.</p> required <code>C</code> <code>float</code> <p>Rate of production of the protein.</p> required <code>D</code> <code>float</code> <p>Rate of degradation of the protein.</p> required <code>num_sites</code> <code>int</code> <p>Number of phosphorylation sites.</p> required <code>params</code> <code>array</code> <p>Parameters for the ODE system.</p> <code>()</code> <code>*params</code> <code>float</code> <p>Additional parameters for the ODE system.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>dydt</code> <code>array</code> <p>Derivatives of the system at the current state.</p>"},{"location":"reference/#models.randmod.solve_ode","title":"<code>solve_ode(popt, y0, num_sites, t)</code>","text":"<p>Solve the Random ODE system using the provided parameters and initial conditions. The function integrates the ODE system over the specified time points and returns the solution.</p> <p>Parameters:</p> Name Type Description Default <code>popt</code> <code>array</code> <p>Parameters for the ODE system.</p> required <code>y0</code> <code>array</code> <p>Initial conditions for the ODE system.</p> required <code>num_sites</code> <code>int</code> <p>Number of phosphorylation sites.</p> required <code>t</code> <code>array</code> <p>Time points for the integration.</p> required <p>Returns:     sol (array): Solution of the ODE system.     mono (array): Solution of phosphorylation states for each site.</p>"},{"location":"reference/#models.succmod","title":"<code>models.succmod</code>","text":""},{"location":"reference/#models.succmod.ode_core","title":"<code>ode_core(y, A, B, C, D, S_rates, D_rates)</code>","text":"<p>The core of the ODE system for the successive ODE model.</p> <p>The system is defined by the following equations: dR/dt = A - B * R dP/dt = C * R - D * P - S_rates[0] * P + sum(P_sites) dP_sites[i]/dt = S_rates[i] * P - (1.0 + D_rates[i]) * P_sites[i]</p> <p>where: R: the concentration of the mRNA P: the concentration of the protein P_sites: the concentration of the phosphorylated sites A: the rate of production of the mRNA B: the rate of degradation of the mRNA C: the rate of production of the protein D: the rate of degradation of the protein S_rates: the rates of phosphorylation of each site D_rates: the rates of dephosphorylation of each site</p> <p>:param y: :param A: :param B: :param C: :param D: :param S_rates: :param D_rates: :return: derivative of y</p>"},{"location":"reference/#models.succmod.ode_system","title":"<code>ode_system(y, t, params, num_psites)</code>","text":"<p>The ODE system for the successive ODE model.</p> <p>:param y: :param t: :param params: :param num_psites: :return: ode_core(y, A, B, C, D, S_rates, D_rates)</p>"},{"location":"reference/#models.succmod.solve_ode","title":"<code>solve_ode(params, init_cond, num_psites, t)</code>","text":"<p>Solve the ODE system using the given parameters and initial conditions. The function integrates the ODE system over time and returns the solution.</p> <p>:param params: :param init_cond: :param num_psites: :param t: :return: solution, solution of phosphorylated sites</p>"},{"location":"reference/#steady-state-calculation","title":"Steady-State Calculation","text":""},{"location":"reference/#steady.initdist","title":"<code>steady.initdist</code>","text":""},{"location":"reference/#steady.initdist.initial_condition","title":"<code>initial_condition(num_psites: int) -&gt; list</code>","text":"<p>Calculates the initial steady-state conditions for a given number of phosphorylation sites for distributive phosphorylation model.</p> <p>This function defines a system of equations representing the steady-state conditions of an ODE model and solves it using numerical optimization. The steady-state conditions are used as initial conditions for further simulations.</p> <p>Parameters:</p> Name Type Description Default <code>num_psites</code> <code>int</code> <p>Number of phosphorylation sites in the model.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of steady-state values for the variables [R, P, P_sites].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the optimization fails to find a solution for the steady-state conditions.</p>"},{"location":"reference/#steady.initrand","title":"<code>steady.initrand</code>","text":""},{"location":"reference/#steady.initrand.initial_condition","title":"<code>initial_condition(num_psites: int) -&gt; list</code>","text":"<p>Calculates the initial steady-state conditions for a given number of phosphorylation sites for random phosphorylation model.</p> <p>This function defines a system of equations representing the steady-state conditions of an ODE model and solves it using numerical optimization. The steady-state conditions are used as initial conditions for further simulations.</p> <p>Parameters:</p> Name Type Description Default <code>num_psites</code> <code>int</code> <p>Number of phosphorylation sites in the model.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of steady-state values for the variables [R, P, P_sites].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the optimization fails to find a solution for the steady-state conditions.</p>"},{"location":"reference/#steady.initsucc","title":"<code>steady.initsucc</code>","text":""},{"location":"reference/#steady.initsucc.initial_condition","title":"<code>initial_condition(num_psites: int) -&gt; list</code>","text":"<p>Calculates the initial steady-state conditions for a given number of phosphorylation sites for successive phosphorylation model.</p> <p>This function defines a system of equations representing the steady-state conditions of an ODE model and solves it using numerical optimization. The steady-state conditions are used as initial conditions for further simulations.</p> <p>Parameters:</p> Name Type Description Default <code>num_psites</code> <code>int</code> <p>Number of phosphorylation sites in the model.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of steady-state values for the variables [R, P, P_sites].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the optimization fails to find a solution for the steady-state conditions.</p>"},{"location":"reference/#plotting","title":"Plotting","text":""},{"location":"reference/#plotting.plotting","title":"<code>plotting.plotting</code>","text":""},{"location":"reference/#plotting.plotting.Plotter","title":"<code>Plotter</code>","text":"<p>A class to encapsulate plotting functionalities for ODE model analysis.</p> <p>Attributes:</p> Name Type Description <code>gene</code> <code>str</code> <p>The gene or experiment name.</p> <code>out_dir</code> <code>str</code> <p>The directory where plots will be saved.</p> <code>color_palette</code> <code>list</code> <p>List of color codes used for plotting.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_parallel","title":"<code>plot_parallel(solution: np.ndarray, labels: list)</code>","text":"<p>Plots a parallel coordinates plot for the given solution.</p> <p>:param solution: 2D numpy array of shape (sampels, features) :param labels: list of labels</p>"},{"location":"reference/#plotting.plotting.Plotter.pca_components","title":"<code>pca_components(solution: np.ndarray, target_variance: float = 0.99)</code>","text":"<p>Plots a scree plot showing the explained variance ratio for PCA components.</p> <p>:param solution: 2D numpy array of shape (samples, features) representing the data. :param target_variance: The target cumulative explained variance to determine the required number of components. :return: A tuple containing the number of required components and the explained variance ratio.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_pca","title":"<code>plot_pca(solution: np.ndarray, components: int = 3)</code>","text":"<p>Plots the PCA results for the given solution.</p> <p>:param solution: 2D numpy array of shape (samples, features) representing the data. :param components: Number of PCA components to plot. Defaults to 3.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_tsne","title":"<code>plot_tsne(solution: np.ndarray, perplexity: int = 30)</code>","text":"<p>Plots a t-SNE visualization of the given solution.</p> <p>:param solution: 2D numpy array of shape (samples, features) representing the data. :param perplexity: Perplexity parameter for t-SNE. Defaults to 30.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_param_series","title":"<code>plot_param_series(estimated_params: list, param_names: list, time_points: np.ndarray)</code>","text":"<p>Plots the time series of estimated parameters over the given time points.</p> <p>This method visualizes the evolution of kinetic rates or parameters over time for a specific gene.</p> <p>:param estimated_params: List of estimated parameter values at each time point. :param param_names: List of parameter names corresponding to the estimated parameters. :param time_points: 1D numpy array of time points.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_profiles","title":"<code>plot_profiles(data: pd.DataFrame)</code>","text":"<p>Plots the profiles of estimated parameters over time.</p> <p>:param data: DataFrame containing the estimated parameters and time points.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_model_fit","title":"<code>plot_model_fit(model_fit: np.ndarray, P_data: np.ndarray, R_data: np.ndarray, sol: np.ndarray, num_psites: int, psite_labels: list, time_points: np.ndarray)</code>","text":"<p>Plots the model fit for the given data.</p> <p>:param model_fit: Estimated model fit values. :param P_data: Observed data for phosphorylation levels. :param R_data: Observed data for mRNA levels. :param sol: ODE solution for mRNA and protein levels. :param num_psites: number of phosphorylation sites. :param psite_labels: labels for the phosphorylation sites. :param time_points: time points for the data. :return:</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_param_scatter","title":"<code>plot_param_scatter(est_arr: np.ndarray, num_psites: int, time_vals: np.ndarray)</code>","text":"<p>Plots scatter and density plots for (A, S), (B, S), (C, S), (D, S).</p> <p>:param est_arr: Estimated parameters array. :param num_psites: Number of phosphorylation sites. :param time_vals: Time values for the data.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_heatmap","title":"<code>plot_heatmap(param_value_df: pd.DataFrame)</code>","text":"<p>Expects param_value_df to have a 'Protein' column.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_error_distribution","title":"<code>plot_error_distribution(error_df: pd.DataFrame)</code>","text":"<p>Expects error_df to have a 'MAE' column.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_gof","title":"<code>plot_gof(merged_data: pd.DataFrame)</code>","text":"<p>Plot the goodness of fit for the model.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_kld","title":"<code>plot_kld(merged_data: pd.DataFrame)</code>","text":"<p>Plots the Kullback-Divergence for the model.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_params_bar","title":"<code>plot_params_bar(ci_results: dict, param_labels: list = None, time: str = None)</code>","text":"<p>Plots bar plot for estimated parameter with 95% Confidence Interval.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_knockouts","title":"<code>plot_knockouts(results_dict: dict, num_psites: int, psite_labels: list)</code>","text":"<p>Plot wild-type and knockout simulation results for comparison.</p>"},{"location":"reference/#plotting.plotting.Plotter.plot_top_param_pairs","title":"<code>plot_top_param_pairs(excel_path: str, top_n: int = 20)</code>","text":"<p>For each gene's '_perturbations' sheet in the Excel file, plot scatter plots for the top N parameter pairs with the highest correlation.</p> <p>Parameters:</p> Name Type Description Default <code>excel_path</code> <code>str</code> <p>Path to the Excel file.</p> required <code>top_n</code> <code>int</code> <p>Number of top parameter pairs to plot.</p> <code>20</code>"},{"location":"reference/#utility-functions","title":"Utility Functions","text":""},{"location":"reference/#utils.display","title":"<code>utils.display</code>","text":""},{"location":"reference/#utils.display.ensure_output_directory","title":"<code>ensure_output_directory(directory)</code>","text":"<p>Ensure the output directory exists. If it doesn't, create it.</p> <p>:param directory: str</p>"},{"location":"reference/#utils.display.load_data","title":"<code>load_data(excel_file, sheet='Estimated Values')</code>","text":"<p>Load data from an Excel file. The default sheet is \"Estimated Values\".</p> <p>:param excel_file: str :param sheet: str :return: DataFrame :rtype: pd.DataFrame</p>"},{"location":"reference/#utils.display.format_duration","title":"<code>format_duration(seconds)</code>","text":"<p>Format a duration in seconds into a human-readable string. The function converts seconds into a string representation in the format: - \"X sec\" for seconds - \"X min\" for minutes - \"X hr\" for hours</p> <p>:param seconds: float :return: formatted string</p>"},{"location":"reference/#utils.display.merge_obs_est","title":"<code>merge_obs_est(filename)</code>","text":"<p>Loads observed and estimated data from an Excel file where: - Each gene has two sheets: _site_observed and _site_estimates - Rows = Psites with index \"Site/Time(min)\" - Columns = time points (14) <p>Returns:</p> Type Description <p>A DataFrame with columns: Gene, Psite, x1_obs\u2013x14_obs, x1_est\u2013x14_est</p>"},{"location":"reference/#utils.display.save_result","title":"<code>save_result(results, excel_filename)</code>","text":"<p>Save the results to an Excel file with multiple sheets. Each sheet corresponds to a different gene and contains: - Sequential Parameter Estimates - Profiled Estimates (if available) - Errors summary - Model fits for the system - Model fits for each site - Observed data for each site - PCA results - t-SNE results - Knockout results The sheet names are prefixed with the gene name, truncated to 25 characters. Args:     results (list): List of dictionaries containing results for each gene.     excel_filename (str): Path to the output Excel file.</p>"},{"location":"reference/#utils.display.create_report","title":"<code>create_report(results_dir: str, output_file: str = f'{ODE_MODEL}_report.html')</code>","text":"<p>Creates a single global report HTML file from all gene folders inside the results directory.</p> <p>For each gene folder (e.g. \"ABL2\"), the report will include:   - All PNG plots and interactive HTML plots displayed in a grid with three plots per row.   - Each plot is confined to a fixed size of 900px by 900px.   - Data tables from XLSX or CSV files in the gene folder are displayed below the plots, one per row.</p> <p>Parameters:</p> Name Type Description Default <code>results_dir</code> <code>str</code> <p>Path to the root result's directory.</p> required <code>output_file</code> <code>str</code> <p>Name of the generated global report file (placed inside results_dir).</p> <code>f'{ODE_MODEL}_report.html'</code>"},{"location":"reference/#utils.display.organize_output_files","title":"<code>organize_output_files(*directories)</code>","text":"<p>Organize output files into protein-specific folders and a general folder. Files matching the pattern \"protein_name_*.{json,svg,png,html,csv,xlsx}\" will be moved to a folder named after the protein. Remaining files will be moved to a \"General\" folder within the same directory.</p> <p>:param directories: List of directories to organize. :type directories: list</p>"},{"location":"reference/#utils.tables","title":"<code>utils.tables</code>","text":""},{"location":"reference/#utils.tables.generate_tables","title":"<code>generate_tables(xlsx_file_path)</code>","text":"<p>Generate hierarchical tables from the XLSX file containing alpha and beta values. The function reads the alpha and beta values from the specified XLSX file, processes them to create hierarchical tables, and returns a list of these tables. Each table is a DataFrame with a MultiIndex for the columns, representing the alpha and beta values for different kinases and phosphorylation sites. The tables are structured to facilitate easy comparison and analysis of the phosphorylation data.</p>"},{"location":"reference/#utils.tables.save_tables","title":"<code>save_tables(tables, output_dir)</code>","text":"<p>Save the generated tables as LaTeX and CSV files. Each table is saved with a filename based on the protein and phosphorylation site. The LaTeX files are formatted for easy inclusion in a larger document, and the CSV files are saved for further analysis.</p> <p>:param tables: List of tuples containing protein, psite, and the corresponding table. :param output_dir: Directory where the tables will be saved. :type output_dir: str</p>"},{"location":"reference/#utils.tables.save_master_table","title":"<code>save_master_table(folder='latex', output_file='latex/all_tables.tex')</code>","text":"<p>Save a master LaTeX file that includes all individual LaTeX files from the specified folder. This function generates a LaTeX file that includes all the individual LaTeX files for each protein and phosphorylation site.</p> <p>:param folder: Directory containing the individual LaTeX files. :param output_file: Output LaTeX file name. :type folder: str :type output_file: str</p>"},{"location":"reference/#utils.latexit","title":"<code>utils.latexit</code>","text":""},{"location":"Documentation/CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"Documentation/CHANGELOG/#010-2025-04-19","title":"[0.1.0] - 2025-04-19","text":""},{"location":"Documentation/CHANGELOG/#added","title":"Added","text":"<ul> <li>Initial release of PhosKinTime, a Python toolkit for ODE-based modeling of phosphorylation kinetics and transcriptional time-series.</li> <li>Features include:</li> <li>Parameter estimation.</li> <li>Sensitivity analysis.</li> <li>Steady-state computation.</li> <li>Interactive visualization.</li> <li>Support for Python 3.10, 3.11, and 3.12.</li> <li>Dependencies include <code>numpy</code>, <code>pandas</code>, <code>seaborn</code>, <code>matplotlib</code>, <code>scipy</code>, and more.</li> <li>CLI entry point <code>phoskintime</code> via <code>bin.main:main</code> in root.</li> <li>Packaged directories: <code>bin</code>, <code>config</code>, <code>kinopt</code>, <code>models</code>, <code>paramest</code>, <code>plotting</code>, <code>sensitivity</code>, <code>steady</code>, <code>tfopt</code>, and <code>utils</code>.</li> <li>Documentation and homepage available at https://bibymaths.github.io/phoskintime/. </li> </ul>"},{"location":"Documentation/CHANGELOG/#020-2025-04-24","title":"[0.2.0] - 2025-04-24","text":""},{"location":"Documentation/CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Added light grid in plotting of model.</li> <li>Added <code>CHANGELOG.md</code>.</li> <li>Added direct link to open file from CLI.</li> <li>Added CLI wrappers for entry point.</li> <li>Added deployment configuration file.</li> <li>Added support for network via Cytoscape.</li> <li>Added configuration file for PhosKinTime settings.</li> <li>Enhanced analysis and plotting functions: added upper bound parameter, updated loss type defaults, and improved legend formatting.</li> </ul>"},{"location":"Documentation/CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Updated parameter bounds and model settings in configuration files.</li> <li>Refactored logging statements and improved data filtering in main processing files.</li> </ul>"},{"location":"Documentation/CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Fixed display of missing kinases in output before optimization in <code>kinopt</code>.</li> </ul>"},{"location":"Documentation/CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Removed clipping of predicted expression.</li> <li>Deleted <code>abopt</code> directory.</li> </ul>"},{"location":"Documentation/CHANGELOG/#030-2025-04-24","title":"[0.3.0] - 2025-04-24","text":""},{"location":"Documentation/CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Support for non-psite time series in kinase data.</li> <li>New results directory for structured output saving.</li> <li>Detailed docstrings and inline documentation for key functions.</li> </ul>"},{"location":"Documentation/CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Refactored <code>powell.jl</code>: cleaner function names, improved parameter handling, and threading support.</li> <li>Updated threading configuration and residuals calculation.</li> <li>Replaced print statements with logger output in Python modules.</li> <li>Adjusted beta bounds and default loss function settings.</li> <li>Improved ODE system equations, plotting aesthetics, and documentation structure.</li> </ul>"},{"location":"Documentation/CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>LaTeX formatting in README.md.</li> <li>Sheet name for estimated values in Excel export.</li> </ul>"},{"location":"Documentation/CHANGELOG/#removed_1","title":"Removed","text":"<ul> <li>Obsolete <code>abopt</code> directory.</li> <li>Outdated module references and unused code. </li> <li>Removed julia implementation of kinopt  </li> <li>Removed Project.toml for Julia dependency management.</li> </ul>"},{"location":"Documentation/bin/","title":"ODE Estimation - Entry Point","text":"<p>This tool performs parallelized parameter estimation for phosphorylation dynamics models using time series data. It reads input from an Excel sheet, processes each gene using a custom ODE-based fitting routine, and outputs results, organized files, and an HTML report.</p>"},{"location":"Documentation/bin/#features","title":"Features","text":"<ul> <li>Parallel processing of multiple genes using <code>ProcessPoolExecutor</code></li> <li>Configurable parameter bounds, fixed values, and bootstrap settings</li> <li>Logging and error handling</li> <li>Report and result generation</li> </ul>"},{"location":"Documentation/bin/#input-format","title":"Input Format","text":"<p>Excel file with sheet name <code>Estimated</code>, and columns:</p> <ul> <li><code>Gene</code> (str)</li> <li><code>Psite</code> (str)</li> <li><code>x1</code> to <code>x14</code> (float): Time series data points</li> </ul>"},{"location":"Documentation/bin/#configuration","title":"Configuration","text":"<p>Configuration is passed via command-line arguments and processed using <code>config/config.py</code>. Key parameters include:</p> <ul> <li><code>input_excel</code>: Path to Excel file</li> <li><code>bounds</code>, <code>fixed_params</code>: Estimation constraints</li> <li><code>bootstraps</code>, <code>time_fixed</code>: Optional features</li> <li><code>profile_start</code>, <code>profile_end</code>, <code>profile_step</code>: Optional profiling range</li> </ul>"},{"location":"Documentation/bin/#output","title":"Output","text":"<ul> <li>Fitted results saved as Excel in <code>OUT_RESULTS_DIR</code></li> <li>HTML report generated in <code>OUT_DIR/report.html</code></li> <li>Logs and intermediate files organized in <code>OUT_DIR</code></li> </ul>"},{"location":"Documentation/bin/#notes","title":"Notes","text":"<ul> <li>By default, only the first gene is processed (for testing).</li> <li>Make sure required columns exist in your input Excel sheet.</li> </ul>"},{"location":"Documentation/config/","title":"Config Module","text":"<p>The config module centralizes all configuration, constant definitions, command-line argument parsing, and logging setup for the PhosKinTime package. This module is designed to standardize configuration settings across the package, making it easy to adjust model parameters, file paths, logging behavior, and other key settings.</p>"},{"location":"Documentation/config/#overview","title":"Overview","text":"<p>The config module is composed of several submodules:</p> <ul> <li><code>constants.py</code>   This file defines global constants used throughout the package. It includes:</li> <li>Model Settings: <ul> <li><code>ODE_MODEL</code>: Selects the ODE model type (e.g., \"distmod\" for Distributive, \"succmod\" for Successive, \"randmod\" for Random).</li> <li><code>ESTIMATION_MODE</code>: Chooses the parameter estimation strategy (\"sequential\" or \"normal\").</li> <li>A mapping (<code>model_names</code>) that converts internal model identifiers to human-readable names (stored in <code>model_type</code>).</li> </ul> </li> <li>Time Points and Directories: <ul> <li><code>TIME_POINTS</code>: A NumPy array of time points for phosphorylation. </li> <li><code>TIME_POINTS_RNA</code>: A NumPy array of time points for mRNA measurements.</li> <li>Directory paths such as <code>PROJECT_ROOT</code>, <code>OUT_DIR</code>, <code>DATA_DIR</code>, <code>INPUT_EXCEL</code>, and <code>LOG_DIR</code>.</li> </ul> </li> <li>Plotting and Regularization Settings: <ul> <li><code>COLOR_PALETTE</code>: A list of colors for plotting.</li> <li><code>USE_REGULARIZATION</code> and <code>LAMBDA_REG</code>: Settings to enable and control Tikhonov (L2) regularization during model fitting.</li> </ul> </li> <li> <p>Scoring Weights:     Weights for the composite scoring function (<code>ALPHA_WEIGHT</code>, <code>BETA_WEIGHT</code>, <code>GAMMA_WEIGHT</code>, <code>DELTA_WEIGHT</code>, <code>MU_REG</code>) that combine error metrics such as RMSE, MAE, variance, MSE, and the L2 norm of parameters.</p> </li> <li> <p><code>config.py</code>   This file handles command-line argument parsing and configuration extraction. It provides:</p> </li> <li>Custom parsers (e.g., <code>parse_bound_pair</code> and <code>parse_fix_value</code>) to validate and convert command-line inputs.</li> <li>The <code>parse_args</code> function to define and parse the necessary CLI arguments (such as parameter bounds, fixed parameter values, bootstrapping iterations, and input file paths).</li> <li>Utility functions like <code>ensure_output_directory</code> to create necessary directories.</li> <li>The <code>extract_config</code> function, which aggregates all command-line arguments and constants into a unified configuration dictionary used by the rest of the package.</li> <li> <p>A composite scoring function (<code>score_fit</code>) that calculates a combined error score based on various error metrics and the L2 regularization penalty.</p> </li> <li> <p><code>logconf.py</code>   This file sets up the logging system for the package. Key features include:</p> </li> <li>Colored Console Logging:     A custom <code>ColoredFormatter</code> formats log messages with colors (e.g., blue for INFO, red for ERROR) to improve readability in the console.</li> <li>Rotating File Logging:     Log messages are also saved to files in the directory specified by <code>LOG_DIR</code>, with rotation settings (maximum bytes and backup count) to prevent log files from becoming too large.</li> <li>Setup Function:     The <code>setup_logger</code> function initializes and returns a logger configured with both file and stream (console) handlers.</li> </ul>"},{"location":"Documentation/config/#global-configuration","title":"Global Configuration","text":"<p>The constants defined in <code>constants.py</code> control major aspects of the modeling and estimation processes. For example, to switch between different kinetic models, update the <code>ODE_MODEL</code> value. Similarly, change <code>ESTIMATION_MODE</code> to \"sequential\" or \"normal\" depending on whether you want time-point-by-time-point estimation or a global fit over all time points.</p>"},{"location":"Documentation/config/#logging","title":"Logging","text":"<p>The logger configured in <code>logconf.py</code> is used to log progress, warnings, and errors. Both console and file logging are available. Log messages include time stamps, module names, log levels, and elapsed time, formatted with colors for easier debugging.</p>"},{"location":"Documentation/config/#customization","title":"Customization","text":"<ul> <li> <p>Model &amp; Estimation Settings:   Adjust <code>ODE_MODEL</code> in <code>constants.py</code> to select different modeling strategies and parameter estimation routines.</p> </li> <li> <p>Parameter Bounds and Fixed Values:   These can be set via command-line arguments or within the configuration file. Custom parsers ensure values are correctly converted (e.g., converting \"inf\" to Python\u2019s infinity).</p> </li> <li> <p>Output Directories:   Paths for data, results, and logs are automatically generated relative to <code>PROJECT_ROOT</code>. Modify these if necessary for your environment.</p> </li> <li> <p>Logging Behavior:   The logging format and rotation settings can be adjusted in <code>logconf.py</code> to suit your needs.</p> </li> <li> <p>Scoring Function:   The composite scoring function in <code>config.py</code> can be tuned by modifying the weights (<code>ALPHA_WEIGHT</code>, <code>BETA_WEIGHT</code>, etc.) to reflect the priorities of your analysis.</p> </li> </ul>"},{"location":"Documentation/kinopt/","title":"kinopt: A Comprehensive Optimization Framework for PhosKinTime","text":"<p>kinopt is a modular framework designed for the analysis and optimization of gene\u2013phosphorylation time-series data. It integrates several specialized submodules that cater to different optimization strategies and post-processing analyses. Whether you need a global evolutionary approach, a local constrained optimization, or a Julia-based Powell optimization routine, kinopt offers the tools to process your experimental data and generate in-depth reports on model performance.</p>"},{"location":"Documentation/kinopt/#directory-structure","title":"Directory Structure","text":"<pre><code>kinopt/\n\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 input1.csv             # Primary input data file with phosphorylation time series data.\n\u2502   \u2514\u2500\u2500 input2.csv             # Interaction data file containing protein-phosphorylation-kinase information.\n\u251c\u2500\u2500 evol\n\u2502   \u251c\u2500\u2500 config                 # Configuration files (constants, logging, etc.) for the evolutionary approach.\n\u2502   \u251c\u2500\u2500 exporter               # Plotting and Excel sheet export functions.\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 __main__.py            # Entry point for global optimization using evolutionary algorithms.\n\u2502   \u251c\u2500\u2500 objfn                  # Objective function implementations (single- and multi-objective).\n\u2502   \u251c\u2500\u2500 opt                    # Optimization routines (integration with pymoo).\n\u2502   \u251c\u2500\u2500 optcon                 # Functions to construct input data, constraints, and precomputed mappings.\n\u2502   \u251c\u2500\u2500 README.md              # Detailed readme for the evol module.\n\u2502   \u2514\u2500\u2500 utils                  # Utility functions for data I/O and parameter extraction.\n\u251c\u2500\u2500 fitanalysis\n\u2502   \u251c\u2500\u2500 helpers                # Auxiliary scripts for additional performance evaluation.\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 __main__.py            # Entry point for fit analysis.\n\u251c\u2500\u2500 local\n\u2502   \u251c\u2500\u2500 config                 # Configuration files specific to local optimization.\n\u2502   \u251c\u2500\u2500 exporter               # Functions for exporting local optimization results and diagnostic plots.\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 __main__.py            # Entry point for local optimization (SLSQP/TRUST-CONSTR based).\n\u2502   \u251c\u2500\u2500 objfn                  # Local objective function implementations with Numba acceleration.\n\u2502   \u251c\u2500\u2500 opt                    # Local optimization routines using SciPy.\n\u2502   \u251c\u2500\u2500 optcon                 # Construction of local constraints and precomputation of mappings.\n\u2502   \u251c\u2500\u2500 README.md              # Detailed readme for the local module.\n\u2502   \u2514\u2500\u2500 utils                  # Utilities for data scaling, file organization, and report generation.\n\u251c\u2500\u2500 optimality\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 KKT.py                 # Post-optimization analysis: feasibility, sensitivity, and reporting.\n\u2502   \u2514\u2500\u2500 README.md              # Detailed readme for the optimality module.\n\u251c\u2500\u2500 __init__.py\n</code></pre>"},{"location":"Documentation/kinopt/#overview","title":"Overview","text":"<p>kinopt provides an end-to-end solution for:</p> <ul> <li> <p>Data Preparation:   Preprocess and scale input CSV files containing time-series data and kinase interactions.</p> </li> <li> <p>Global Optimization (evol):   Uses evolutionary algorithms (via pymoo) to search the global parameter space for optimal \u03b1 (mixing) and \u03b2 (scaling) values.</p> </li> <li> <p>Local Optimization (local):   Implements local constrained optimization using SciPy's solvers (SLSQP or TRUST-CONSTR) with efficient objective evaluation via Numba.</p> </li> <li> <p>Optimality Analysis (optimality):   Post-processes optimization results to check constraint feasibility, perform sensitivity analysis, generate LaTeX summary tables, and produce diagnostic plots.</p> </li> <li> <p>Fit Analysis (fitanalysis):   Provides additional tools to evaluate the fit and performance of the optimized model.</p> </li> </ul>"},{"location":"Documentation/kinopt/#features","title":"Features","text":"<ul> <li> <p>Modular Architecture:   Each submodule (evol, local, optimality, fitanalysis) is designed to operate independently while integrating seamlessly into the overall workflow.</p> </li> <li> <p>Flexible Optimization Strategies:   Choose between global evolutionary algorithms, local constrained solvers depending on your specific needs.</p> </li> <li> <p>Robust Post-Processing:   Comprehensive post-optimization analysis includes constraint validation, sensitivity analysis, detailed reporting (both in LaTeX and Excel), and extensive plotting of diagnostic metrics.</p> </li> <li> <p>Automated Reporting:   After running optimization routines, the framework organizes outputs into structured directories and generates a global HTML report summarizing key results and diagnostic plots.</p> </li> <li> <p>User-Friendly Logging:   Custom logging configurations provide real-time feedback during execution, ensuring transparency in the optimization process.</p> </li> </ul>"},{"location":"Documentation/kinopt/#usage","title":"Usage","text":"<p>Go to the one top level up in the terminal from root and run:</p>"},{"location":"Documentation/kinopt/#running-global-optimization-evol","title":"Running Global Optimization (evol)","text":"<pre><code>python -m phoskintime kinopt --mode evol\n</code></pre>"},{"location":"Documentation/kinopt/#running-local-optimization-local","title":"Running Local Optimization (local)","text":"<pre><code>python -m phoskintime kinopt --mode local\n</code></pre>"},{"location":"Documentation/kinopt/#post-optimization-processing","title":"Post-Optimization Processing","text":"<p>After any optimization run, the optimality module is invoked (either directly or as part of the workflow) to analyze the results, validate constraints, and generate comprehensive reports.</p>"},{"location":"Documentation/kinopt/#contributing-license","title":"Contributing &amp; License","text":"<p>Contributions are welcome! Please refer to the main repository documentation for guidelines on contributing, reporting issues, and feature requests.</p> <p>kinopt is distributed under the BSD Clause 3 license. See the LICENSE file in the repository for more details.</p> <p>This README provides an overview of the kinopt framework, outlining its structure, features, and usage instructions. For detailed documentation on each submodule, please refer to the individual README.md files within the respective directories.</p>"},{"location":"Documentation/models/","title":"Models","text":"<p>The models module provides the implementation of various ODE-based kinetic models used in the PhosKinTime package for phosphorylation dynamics. It is designed to support multiple model types, each corresponding to a different mechanistic hypothesis about how phosphorylation occurs.</p>"},{"location":"Documentation/models/#1-distributive-model","title":"1. Distributive Model","text":"<ul> <li>$R$: mRNA concentration  </li> <li>$P$: protein concentration  </li> <li>$P_i$: phosphorylated site $i$  </li> <li>$A, B, C, D$: rate constants  </li> <li>$S_i$: phosphorylation rate for site $i$  </li> <li>$D_i$: dephosphorylation rate for site $i$  </li> </ul> <p>Equations:</p> <ul> <li>$ \\frac{dR}{dt} = A - B R $</li> <li>$ \\frac{dP}{dt} = C R - (D + \\sum_i S_i) P + \\sum_i P_i $</li> <li>$ \\frac{dP_i}{dt} = S_i P - (1 + D_i) P_i \\quad \\forall i $</li> </ul>"},{"location":"Documentation/models/#2-successive-model","title":"2. Successive Model","text":"<ul> <li>$R, P, P_i$ as above  </li> <li>Phosphorylation proceeds in sequence  </li> </ul> <p>Equations:</p> <ul> <li>$ \\frac{dR}{dt} = A - B R $</li> <li>$ \\frac{dP}{dt} = C R - D P - S_0 P + P_0 $</li> </ul> <p>Phosphorylation sites:</p> <ul> <li> <p>First site ($i = 0$):   $ \\frac{dP_0}{dt} = S_0 P - (1 + S_1 + D_0) P_0 + P_1 $</p> </li> <li> <p>Intermediate sites ($0 &lt; i &lt; n-1$):   $ \\frac{dP_i}{dt} = S_i P_{i-1} - (1 + S_{i+1} + D_i) P_i + P_{i+1} $</p> </li> <li> <p>Last site ($i = n - 1$):   $ \\frac{dP_{n-1}}{dt} = S_{n-1} P_{n-2} - (1 + D_{n-1}) P_{n-1} $</p> </li> </ul>"},{"location":"Documentation/models/#3-random-model","title":"3. Random Model","text":"<ul> <li>$X_j$: phosphorylated state $j$, total $2^n - 1$ states  </li> <li>$S_i$: phosphorylation rates for each site  </li> <li>$D_j$: degradation rate for state $j$  </li> <li>Binary transitions determine phosphorylation and dephosphorylation  </li> </ul> <p>Equations:</p> <ul> <li>$ \\frac{dR}{dt} = A - B R $</li> <li>$ \\frac{dP}{dt} = C R - D P - (\\sum_i S_i) P + \\sum_{j \\in \\text{1-site}} X_j + \\sum_{j \\in \\text{dephospho exit}} S_i X_j $</li> </ul> <p>Each state $X_j$:</p> <ul> <li>$ \\frac{dX_j}{dt} = \\sum_{\\text{phospho from}} S_i X_{src} - (\\sum_i S_i + D_j) X_j + \\sum_{\\text{dephospho to}} S_i X_{src} $</li> </ul>"},{"location":"Documentation/models/#weights","title":"Weights","text":""},{"location":"Documentation/models/#without-regularization","title":"Without Regularization","text":"<p>Let: - $x_i$: the data point at time $i$ - $t_i$: the time point index ($i = 1, 2, \\dots$) - $T$: total number of time points - $w_i$: weight at time $i$</p> <p>Basic schemes:</p> <ul> <li> <p>Inverse Data:   $w_i = \\frac{1}{|x_i| + \\epsilon}$</p> </li> <li> <p>Exponential Decay:   $w_i = \\exp(-0.5 \\cdot x_i)$</p> </li> <li> <p>Log Scale:   $w_i = \\frac{1}{\\log(1 + |x_i|)}$</p> </li> <li> <p>Time Difference:   $w_i = \\frac{1}{|x_i - x_{i-1}| + \\epsilon}$</p> </li> <li> <p>Moving Average Deviation:   $w_i = \\frac{1}{|x_i - \\text{MA}_i| + \\epsilon}$   where $\\text{MA}_i$ is a moving average (e.g., over 3 points)</p> </li> <li> <p>Sigmoid Time Decay:   $w_i = \\frac{1}{1 + \\exp(t_i - 5)}$</p> </li> <li> <p>Exponential Early Emphasis:   $w_i = \\exp(-0.5 \\cdot t_i)$</p> </li> <li> <p>Polynomial Decay:   $w_i = \\frac{1}{1 + 0.5 \\cdot t_i}$</p> </li> <li> <p>MS SNR Model (Signal-Noise Ratio):   $w_i = \\frac{1}{\\sqrt{|x_i| + \\epsilon}}$</p> </li> <li> <p>MS Inverse Variance Model:   $w_i = \\frac{1}{|x_i|^{0.7} + \\epsilon}$</p> </li> <li> <p>Flat Region Penalty:   $w_i = \\frac{1}{|\\nabla x_i| + \\epsilon}$</p> </li> <li> <p>Steady State Decay:   $w_i = \\exp(-0.1 \\cdot t_i)$</p> </li> <li> <p>Combined Data and Time:   $w_i = \\frac{1}{|x_i| \\cdot (1 + 0.5 \\cdot t_i)}$</p> </li> <li> <p>Inverse Sqrt Data:   $w_i = \\frac{1}{\\sqrt{|x_i| + \\epsilon}}$</p> </li> <li> <p>Early Emphasis (moderate or steep decay):   $w_i = 1$ (or pre-defined stepwise decay vector)</p> </li> <li> <p>Custom Early Emphasis:   Based on:   $w_i = \\frac{1}{(|x_i| + \\epsilon)(\\Delta t_i + \\epsilon)}$ for early $t_i$, else $w_i = 1$</p> </li> </ul>"},{"location":"Documentation/models/#with-regularization","title":"With Regularization","text":"<p>Let $w_i$ be any of the above weights and $R$ be the number of regularization parameters:</p> <ul> <li>Extended Weight Vector:   $w = [w_1, w_2, \\dots, w_T, 1, 1, \\dots, 1]$   where the last $R$ entries are <code>1</code> (flat regularization penalty weights)</li> </ul> <p>This simply appends a vector of ones of length equal to the number of regularization parameters to each weight vector. </p>"},{"location":"Documentation/models/#tikhonov-regularization-in-ode-parameter-estimation","title":"Tikhonov Regularization in ODE Parameter Estimation","text":"<p>This project applies Tikhonov regularization (\u03bb = 1e-3) to stabilize parameter estimates and improve identifiability in ODE-based model fitting.</p> <ul> <li>Computes unregularized estimates and their covariance matrix.</li> <li>Applies Tikhonov regularization post hoc:</li> <li> <p>Regularized estimates:   $$   \\theta_{\\text{reg}} = \\theta_{\\text{fit}} - \\lambda C \\Gamma \\theta_{\\text{fit}}   $$</p> </li> <li> <p>Regularized covariance:   $$   C_{\\text{reg}} = \\left(C^{-1} + \\lambda \\Gamma \\right)^{-1}   $$</p> </li> <li>Typically, <code>\u0393</code> is the identity matrix.</li> </ul>"},{"location":"Documentation/models/#interpretation","title":"Interpretation","text":"<ul> <li>Estimates are shrunk toward zero (or prior).</li> <li>Uncertainty (covariance) is reduced, reflecting added prior information.</li> <li>Regularization improves numerical stability and reduces overfitting.</li> </ul>"},{"location":"Documentation/models/#post-regularization-checks","title":"Post-Regularization Checks","text":"<ul> <li>Compare <code>\u03b8_fit</code> vs <code>\u03b8_reg</code> and <code>C</code> vs <code>C_reg</code>.</li> <li>Assess model fit with regularized parameters.</li> <li>Examine parameter correlations and identifiability.</li> <li>Optionally test sensitivity to different <code>\u03bb</code> values.</li> </ul>"},{"location":"Documentation/models/#note","title":"Note","text":"<p>This approach assumes the likelihood is locally quadratic\u2014valid for most ODE-based models near optimum. </p>"},{"location":"Documentation/models/#overview","title":"Overview","text":"<p>This module includes implementations of the following model types:</p> <ul> <li> <p>Random Model (<code>randmod.py</code>):   Implements a vectorized and optimized ODE system using Numba. This model represents a random mechanism of phosphorylation, where transitions between phosphorylation states are computed based on binary representations. The module prepares vectorized arrays (e.g., binary states, phosphorylation/dephosphorylation targets) and defines the ODE system accordingly.</p> </li> <li> <p>Distributive Model (<code>distmod.py</code>):   Implements a distributive phosphorylation mechanism. In this model, a kinase adds phosphate groups in a manner where each phosphorylation event is independent, and the ODE system is defined with explicit state variables for the phosphorylated forms.</p> </li> <li> <p>Successive Model (<code>succmod.py</code>):   Implements a successive phosphorylation mechanism, where phosphorylation occurs in a sequential, stepwise manner. This model's ODE system is tailored to capture the sequential nature of the modification.</p> </li> <li> <p>Weighting Functions (<code>weights.py</code>):   Provides functions to compute various weighting schemes (e.g., early emphasis, inverse data, exponential decay) used during parameter estimation. These weights help tailor the fitting process to the dynamics of the observed data.</p> </li> </ul>"},{"location":"Documentation/models/#automatic-model-selection","title":"Automatic Model Selection","text":"<p>The package\u2019s <code>__init__.py</code> file in the models module automatically imports the correct model module based on the configuration constant <code>ODE_MODEL</code>. The selected module\u2019s <code>solve_ode</code> function is then exposed as the default ODE solver for the package. This enables seamless switching between different mechanistic models without changing the rest of the code.</p>"},{"location":"Documentation/models/#key-features","title":"Key Features","text":"<ul> <li> <p>Vectorized Computation and JIT Optimization:   For the random model, vectorized arrays and Numba\u2019s <code>@njit</code> decorator are used to accelerate ODE evaluations.</p> </li> <li> <p>Modular Design:   Each model type is implemented in its own file, allowing easy extension or modification of the underlying kinetics without affecting the overall framework.</p> </li> <li> <p>Flexible Integration:   The models use <code>scipy.integrate.odeint</code> to numerically integrate the ODE system, ensuring robust and accurate simulation of phosphorylation dynamics.</p> </li> <li> <p>Support for Multiple Phosphorylation Sites:   All models are designed to handle an arbitrary number of phosphorylation sites, with appropriate state variable definitions and parameter extraction.</p> </li> <li> <p>Customizable Weighting for Parameter Estimation:   The weights module provides several functions for generating weights (e.g., early emphasis) to be used during the parameter estimation process, enhancing the fitting performance.</p> </li> </ul>"},{"location":"Documentation/models/#dependencies","title":"Dependencies","text":"<ul> <li>NumPy &amp; SciPy: For numerical operations, ODE integration, and optimization.</li> <li>Numba: To accelerate performance-critical functions via just-in-time (JIT) compilation.</li> <li>Other Dependencies: The module works within the PhosKinTime package, leveraging configuration and logging utilities defined elsewhere in the package.</li> </ul>"},{"location":"Documentation/models/#units-in-the-ode-model","title":"Units in the ODE Model","text":"<p>These ODE models supports two interpretations depending on whether quantities are scaled:</p>"},{"location":"Documentation/models/#1-dimensionless-model-scaled","title":"1. Dimensionless Model (Scaled)","text":"<ul> <li>All parameters and variables are unitless.</li> <li>Time and concentrations are rescaled to reference values (e.g., max input, steady state).</li> <li>Useful for qualitative dynamics, numerical stability, or fitting fold-change data.</li> <li>Interpretation:  </li> <li><code>A, B, C, D, S_rates[i], D_rates[i]</code> \u2192 unitless </li> <li><code>y</code> (state vector: R, P, P_sites) \u2192 unitless</li> </ul>"},{"location":"Documentation/models/#2-dimensional-mass-action-style","title":"2. Dimensional (Mass-Action Style)","text":"<ul> <li>Variables represent concentration (e.g., \u03bcM), and time is in seconds.</li> <li>Parameters follow biochemical units:</li> <li><code>A</code> \u2192 concentration/time (e.g., \u03bcM/s)  </li> <li><code>B, C, D, S_rates[i], D_rates[i]</code> \u2192 1/time (e.g., 1/s)  </li> <li><code>R, P, y[2+i]</code> \u2192 concentration (e.g., \u03bcM)</li> <li>Caveat: Dimensional consistency requires adjustment (e.g., replacing hardcoded <code>1.0</code> with a rate constant and scaling summed terms accordingly).</li> </ul> <p>Here\u2019s a concise and clear <code>README</code> section tailored for your PhosKinTime tool, explaining the normalization logic for fold change data:</p>"},{"location":"Documentation/models/#fold-change-normalization-in-phoskintime","title":"Fold Change Normalization in PhosKinTime","text":"<p>PhosKinTime supports modeling and parameter estimation of phosphorylation dynamics using time series data. Often, such experimental data is provided not in absolute concentration units but as fold change (FC) relative to a baseline (usually time point 0). To ensure accurate and biologically meaningful comparison between model output and experimental data, PhosKinTime includes built-in support to normalize model output to fold change form.</p>"},{"location":"Documentation/models/#why-normalize","title":"Why Normalize?","text":"<p>Experimental FC data is typically defined as:</p> <p>$$ \\text{FC}(t) = \\frac{X(t)}{X(t_0)} $$</p> <p>where $X(t)$ is the measured signal (e.g., intensity or concentration) at time $t$, and $X(t_0)$ is the baseline (often the 0 min time point). It reflects relative change, not absolute concentration.</p> <p>However, PhosKinTime's ODE models simulate absolute concentrations over time:</p> <p>$$ Y(t) = \\text{ODE solution} $$</p> <p>Directly comparing $Y(t)$ to FC data is invalid, as it compares mismatched scales and units. To bridge this gap, PhosKinTime transforms the model output into comparable fold change form by:</p> <p>$$ \\text{FC}_{\\text{model}}(t) = \\frac{Y(t)}{Y(t_0) + \\epsilon} $$</p> <p>($\\epsilon$ is a small constant to avoid division by zero.)</p> <p>This transformation is applied per phosphorylation site (or species) independently, ensuring robust and interpretable parameter fitting.</p>"},{"location":"Documentation/models/#references","title":"References","text":"<ul> <li>Klipp, E., et al. (2016). Systems Biology: A Textbook (2nd ed.). Wiley-VCH.  </li> <li>Raue, A., et al. (2013). Lessons learned from quantitative dynamical modeling in systems biology. PLoS ONE, 8(9), e74335.  </li> <li>BioModels Documentation: https://www.ebi.ac.uk/biomodels/docs/</li> </ul>"},{"location":"Documentation/paramest/","title":"Parameter Estimation","text":"<p>This module provides the tools needed to estimate parameters for ODE\u2010based models of phosphorylation dynamics.</p>"},{"location":"Documentation/paramest/#overview","title":"Overview","text":"<p>The module is organized into several submodules:</p> <ul> <li><code>normest.py</code> \u2013 Implements normal parameter estimation. This approach fits the entire time-series data in one step.</li> <li><code>toggle.py</code> \u2013 Offers a single function (<code>estimate_parameters</code>) to pipe normal estimation based on a mode flag.  </li> <li><code>core.py</code> \u2013 Integrates the estimation methods, handling data extraction, calling the appropriate estimation (via the toggle), ODE solution, error calculation, and plotting.</li> </ul>"},{"location":"Documentation/paramest/#features","title":"Features","text":"<ul> <li> <p>Bootstrapping:   Bootstrapping can be enabled to assess the variability of the parameter estimates.</p> </li> <li> <p>Flexible Model Configuration:   The module supports different ODE model types (e.g., Distributive, Successive, Random) through configuration constants. For example, when using the \"randmod\" (Random model), the parameter bounds are log-transformed and the optimizer works in log-space (with conversion back to the original scale).</p> </li> <li> <p>Integration with Plotting:   After estimation, the module calls plotting functions (via the <code>Plotter</code> class) to visualize the ODE solution, parameter profiles, and goodness-of-fit metrics.</p> </li> </ul>"},{"location":"Documentation/paramest/#usage","title":"Usage","text":""},{"location":"Documentation/paramest/#estimation-mode-toggle","title":"Estimation Mode Toggle","text":"<p>The function <code>estimate_parameters(mode, ...)</code> in <code>toggle.py</code> serves as the interface that selects the appropriate routine and returns: - <code>estimated_params</code>: A list of estimated parameter vectors. - <code>model_fits</code>: A list of tuples containing the ODE solution and fitted data. - <code>seq_model_fit</code>: A 2D array of model predictions with shape matching the measurement data. - <code>errors</code>: Error metrics computed during estimation.</p>"},{"location":"Documentation/paramest/#running-the-estimation","title":"Running the Estimation","text":"<p>The main script (<code>core.py</code>) extracts gene-specific data, sets up initial conditions, and calls <code>estimate_parameters</code> (via the toggle) with appropriate inputs such as: - Measurement data (<code>P_data</code>) - Time points - Model bounds and fixed parameter settings - Bootstrapping iteration count</p> <p>After estimation, the final parameter set is used to solve the full ODE system, and various plots (e.g., model fit, PCA, t-SNE, profiles) are generated and saved.</p>"},{"location":"Documentation/paramest/identifiability/","title":"Parameter Identifiability","text":"<p>This module provides a function to compute confidence intervals (CIs) and significance statistics for model parameters using linear approximation based on the covariance matrix from a nonlinear least squares fit.</p>"},{"location":"Documentation/paramest/identifiability/#purpose","title":"Purpose","text":"<p>Given:</p> <ul> <li>Best-fit parameter estimates (<code>popt</code>)</li> <li>Their covariance matrix (<code>pcov</code>)</li> <li>The observed data (<code>target</code>)</li> </ul> <p>This function estimates:</p> <ul> <li>Standard errors</li> <li>t-statistics</li> <li>Two-sided p-values</li> <li>95% confidence intervals (or another level via <code>alpha_val</code>)</li> </ul>"},{"location":"Documentation/paramest/identifiability/#mathematical-background","title":"Mathematical Background","text":""},{"location":"Documentation/paramest/identifiability/#1-standard-error","title":"1. Standard Error","text":"<p>The standard error of each parameter is estimated as:</p> <p>$$ \\text{SE}(\\beta_i) = \\sqrt{ \\text{Var}(\\beta_i) } = \\sqrt{ \\text{diag}(\\text{pcov})_i } $$</p> <p>Where <code>pcov</code> is the covariance matrix from the curve fitting routine (typically from <code>scipy.optimize.curve_fit</code>).</p>"},{"location":"Documentation/paramest/identifiability/#2-degrees-of-freedom","title":"2. Degrees of Freedom","text":"<p>$$ \\text{df} = n_{\\text{obs}} - n_{\\text{params}} $$</p> <p>Used to select the correct t-distribution for the confidence interval and p-value computation.</p>"},{"location":"Documentation/paramest/identifiability/#3-t-statistic","title":"3. t-Statistic","text":"<p>For each parameter:</p> <p>$$ t_i = \\frac{\\hat{\\beta}_i}{\\text{SE}(\\hat{\\beta}_i)} $$</p>"},{"location":"Documentation/paramest/identifiability/#4-p-value","title":"4. p-Value","text":"<p>Two-sided p-value from the Student\u2019s t-distribution:</p> <p>$$ p_i = 2 \\cdot P(T &gt; |t_i|) = 2 \\cdot \\text{sf}(|t_i|, \\text{df}) $$</p>"},{"location":"Documentation/paramest/identifiability/#5-confidence-interval","title":"5. Confidence Interval","text":"<p>Using the t-critical value $t^*$:</p> <p>$$ t^* = t_{1 - \\alpha/2, \\text{df}} $$</p> <p>Confidence bounds:</p> <p>$$ \\text{CI}_i = \\left[ \\max\\left(0, \\hat{\\beta}_i - t^* \\cdot \\text{SE}(\\hat{\\beta}_i)\\right),\\ \\hat{\\beta}_i + t^* \\cdot \\text{SE}(\\hat{\\beta}_i) \\right] $$</p> <p>Lower bound is clipped to zero for non-negative parameters.</p>"},{"location":"Documentation/paramest/identifiability/#when-to-use","title":"When to Use","text":"<ul> <li>To assess parameter certainty</li> <li>To report statistical significance and error bars</li> </ul>"},{"location":"Documentation/sensitivity/","title":"Sensitivity Analysis","text":"<p>The Sensitivity module provides functionality for performing sensitivity analysis on the ODE-based phosphorylation models in the PhosKinTime package. Using the Morris method from SALib, this module evaluates the influence of each model parameter on the output of the system, thereby helping to identify the most critical parameters and potential nonlinear interactions.</p>"},{"location":"Documentation/sensitivity/#overview","title":"Overview","text":"<p>This module (primarily implemented in <code>analysis.py</code>) defines functions that: - Define the Sensitivity Problem:   Two functions (<code>define_sensitivity_problem_rand</code> and <code>define_sensitivity_problem_ds</code>) generate the problem definition (number of variables, parameter names, and bounds) required for the Morris sensitivity analysis. The choice depends on whether the model is a random model (<code>randmod</code>) or a distributive/successive model.</p> <ul> <li>Run Sensitivity Analysis:   The <code>sensitivity_analysis</code> function:</li> <li>Generates parameter samples using the Morris method.</li> <li>Simulates the ODE system (via the package's <code>solve_ode</code> function) for each parameter set.</li> <li>Computes a response metric (e.g., the sum of the phosphorylated states at the final time point).</li> <li>Analyzes the sensitivity indices using SALib's <code>analyze</code> function.</li> <li>Generates a suite of plots (bar plots, scatter, radial, CDF, and pie charts) to visually summarize the sensitivity of each parameter.</li> </ul>"},{"location":"Documentation/sensitivity/#features","title":"Features","text":"<ul> <li> <p>Model-Specific Sensitivity Problem Definition:   Generates problem definitions tailored to either the random model or the distributive/successive models, automatically adjusting the number of parameters and their bounds.</p> </li> <li> <p>Comprehensive Sensitivity Analysis:   Uses the Morris method to provide:</p> </li> <li>Mu* (Mean Absolute Effect): Indicates overall parameter importance.</li> <li> <p>Sigma (Standard Deviation): Reflects the degree of nonlinearity or interaction in parameter effects.</p> </li> <li> <p>Automated Plotting:   The module creates and saves multiple plots:</p> </li> <li>Bar plots for mu* and sigma.</li> <li>Scatter plot of mu* versus sigma.</li> <li>A radial (spider) plot summarizing sensitivity metrics.</li> <li>Cumulative Distribution Function (CDF) plot of sensitivity indices.</li> <li>Pie chart showing the proportional sensitivity contribution of each parameter.</li> </ul>"},{"location":"Documentation/sensitivity/#usage","title":"Usage","text":"<p>The main function in this module is <code>sensitivity_analysis</code>, which can be called with the following parameters:</p> <ul> <li><code>time_points</code>: A NumPy array of experimental time points.</li> <li><code>num_psites</code>: Number of phosphorylation sites.</li> <li><code>init_cond</code>: The initial conditions for the ODE simulation.</li> <li><code>gene</code>: The gene (or protein) identifier for which sensitivity is analyzed.</li> </ul>"},{"location":"Documentation/steady/","title":"Steady-State Initializers for Phosphorylation Models","text":"<p>These scripts compute biologically meaningful steady-state initial values for different phosphorylation models, which are required as starting points for ODE simulations.</p> <p>Instead of guessing or using arbitrary initial values, we solve a nonlinear system of equations that ensures:</p> <p>All time derivatives are zero at $t = 0$ \u2192 i.e., the system is at equilibrium</p>"},{"location":"Documentation/steady/#what-is-being-computed","title":"What Is Being Computed?","text":"<p>For each model, we're solving:</p> <p>$$ \\text{Find } y_0 \\text{ such that } \\frac{dy}{dt}\\bigg|_{t=0} = 0 $$</p> <p>where $\\mathbf{y} = [R, P, \\dots]$ are all species in the system.</p> <p>This is done using constrained numerical optimization (<code>scipy.optimize.minimize</code>) to solve a system of equations $f(\\mathbf{y}) = 0$.</p>"},{"location":"Documentation/steady/#model-specific-logic","title":"Model-Specific Logic","text":""},{"location":"Documentation/steady/#1-distributive-model","title":"1. Distributive Model","text":"<ul> <li>Each site $i$ is phosphorylated independently</li> <li>Steady-state means:</li> <li>mRNA synthesis balances degradation</li> <li>Protein synthesis balances degradation and phosphorylation</li> <li>Each phosphorylated state $P_i$ is in flux balance</li> </ul> <p>You solve a nonlinear system:</p> <p>$$ \\begin{aligned} A - B R &amp;= 0 \\ C R - (D + \\sum S_i) P + \\sum P_i &amp;= 0 \\ S_i P - (1 + D_i) P_i &amp;= 0 \\quad \\forall i \\end{aligned} $$</p>"},{"location":"Documentation/steady/#2-successive-model","title":"2. Successive Model","text":"<ul> <li>Sites are phosphorylated in sequence</li> <li>Initial condition requires that flow through the chain is at equilibrium:</li> <li>$P \\rightarrow P_0 \\rightarrow P_1 \\rightarrow \\dots \\rightarrow P_n$</li> </ul> <p>Steady-state means each conversion step: - Has equal incoming and outgoing rates - Balances intermediate accumulations</p> <p>You solve:</p> <p>$$ \\text{Same logic, but with additional internal terms involving adjacent states} $$</p>"},{"location":"Documentation/steady/#3-random-model","title":"3. Random Model","text":"<ul> <li>All possible phosphorylated combinations are treated as distinct states</li> <li>Total number of states = $2^n - 1$ (excluding unphosphorylated state)</li> </ul> <p>You construct a system:</p> <ul> <li>One equation for $R$ and $P$</li> <li>One for each state $X_j$ (each subset of phosphorylated sites)</li> <li>For each state, compute net phosphorylation in/out, and degradation</li> </ul> <p>Mathematically:</p> <p>$$ \\text{Each state } X_j: \\quad \\text{gain from P or other } X_k \\quad - \\quad \\text{loss by phosphorylation, degradation, etc.} = 0 $$</p> <p>This is a sparse, coupled nonlinear system where each subset has dynamic transitions with others.</p>"},{"location":"Documentation/steady/#output","title":"Output","text":"<p>Each function returns steady-state concentrations:</p> <ul> <li>$[R, P, P_1, ..., P_n]$ (for <code>distributive</code> and <code>successive</code>)</li> <li>$[R, P, X_1, ..., X_k]$ (for <code>random</code>, where $X_k$ are the subset states)</li> </ul>"},{"location":"Documentation/tfopt/","title":"tfopt \u2014 Transcription Factor Optimization Framework","text":"<ul> <li>Originally implemented by Julius Normann. </li> <li>This version has been modified and optimized for consistency &amp; speed in submodules by Abhinav Mishra.</li> </ul> <p><code>tfopt</code> provides a flexible architecture for estimating transcriptional regulatory influence using mRNA time series data, TF protein dynamics, and phosphorylation site signals.</p> <p>The package contains two main submodules:</p> <ul> <li><code>tfopt/evol</code> \u2014 global optimization via multi-objective evolutionary algorithms  </li> <li><code>tfopt/local</code> \u2014 constrained optimization using SciPy solvers (e.g., SLSQP)</li> </ul> <p>Both modules share a consistent data preparation pipeline and model formulation.</p>"},{"location":"Documentation/tfopt/#model-equation","title":"Model Equation","text":"<p>For each mRNA (indexed by i), the measured time series is represented by:</p> <p>$$ \\mathbf{R}_i = \\left([mRNA]_i(t_1), [mRNA]_i(t_2), \\dots, [mRNA]_i(T)\\right) $$</p> <p>Its predicted value is modeled as a weighted combination of the effects of transcription factors (TFs) that regulate it. Each TF (indexed by j) contributes in two ways: - A protein component (when no phosphorylation site is reported) with time series ( TF_{i,j}(t) ) - A PSite component (when phosphorylation sites are available) with time series ( PSite_{k,j}(t) ) for each site k</p> <p>These contributions are modulated by two sets of parameters: - \u03b1-values: For each mRNA, the impact of TF j is weighted by ( \\alpha_{i,j} ) - \u03b2-values: For each TF, a vector of weights:</p> <p>$$   \\beta_j = \\left( \\beta_{0,j}, \\beta_{1,j}, \\dots, \\beta_{K_j,j} \\right)   $$</p> <p>Here, $ \\beta_{0,j} $ multiplies the raw TF protein signal, and the remaining terms multiply phosphorylation site contributions.</p> <p>The full predicted mRNA time series is then:</p> <p>$$ \\hat{R}i(t) = \\sumi} \\alpha \\right) $$} \\cdot TF_{i,j}(t) \\left( \\beta_{0,j} + \\sum_{k=1}^{K_j} PSite_{k,j}(t) \\cdot \\beta_{k,j</p> <p>where $ \\mathcal{J}_i $ is the set of TFs regulating gene i (according to the interaction data).</p>"},{"location":"Documentation/tfopt/#objective-function","title":"Objective Function","text":"<p>To estimate the best set of weights, we minimize the difference between measured and predicted expression over all genes and time points:</p> <p>$$ \\min_{{\\alpha,\\beta}} \\quad \\sum_i \\sum_t \\left( R_i(t) - \\hat{R}_i(t) \\right)^2 $$</p> <p>This formulation supports multiple loss types (MSE, MAE, soft L1, Cauchy, etc.) implemented in both submodules.</p>"},{"location":"Documentation/tfopt/#constraints","title":"Constraints","text":""},{"location":"Documentation/tfopt/#-constraints-for-each-mrna-i","title":"\u03b1-constraints (for each mRNA i):","text":"<p>$$ \\sum_{j\\in \\mathcal{J}i} \\alpha \\le 1 $$} = 1, \\quad 0 \\le \\alpha_{i,j</p>"},{"location":"Documentation/tfopt/#-constraints-for-each-tf-j","title":"\u03b2-constraints (for each TF j):","text":"<p>$$ \\sum_{q=0}^{K_j} \\beta_{q,j} = 1, \\quad -2 \\le \\beta_{q,j} \\le 2 $$</p> <p>This ensures that weights are interpretable and stable.</p>"},{"location":"Documentation/tfopt/#optimization-problem-summary","title":"Optimization Problem Summary","text":"<p>The final optimization problem is:</p> <p>$$ \\min_{{\\alpha,\\beta}} \\sum_i \\sum_t \\left( R_i(t) - \\sum_{j\\in \\mathcal{J}i} \\alpha \\right) \\right)^2 $$} \\cdot TF_{i,j}(t) \\left( \\beta_{0,j} + \\sum_{k=1}^{K_j} PSite_{k,j}(t) \\cdot \\beta_{k,j</p> <p>subject to the constraints above. This enables estimation of regulatory influences in a biologically meaningful and data-driven manner.</p>"},{"location":"Documentation/tfopt/#submodules","title":"Submodules","text":""},{"location":"Documentation/tfopt/#evol-global-evolutionary-optimization","title":"<code>evol/</code> \u2014 Global Evolutionary Optimization","text":"<ul> <li>Implements multi-objective optimization using <code>pymoo</code> (NSGA2, AGEMOEA, SMSEMOA)</li> <li>Evaluates tradeoffs between fit error, \u03b1-constraint violation, and \u03b2-constraint violation</li> <li>Outputs Excel summaries, static and interactive plots, and HTML reports</li> </ul>"},{"location":"Documentation/tfopt/#local-constrained-local-optimization","title":"<code>local/</code> \u2014 Constrained Local Optimization","text":"<ul> <li>Implements deterministic solvers (e.g. SLSQP)</li> <li>Faster and more interpretable for small- to medium-scale systems</li> <li>Shares the same objective and constraint framework as <code>evol</code></li> <li>Generates the same reports and plots as the global module</li> </ul>"},{"location":"Documentation/tfopt/#usage","title":"Usage","text":"<p>From one level top of project root:</p> <pre><code>python -m phoskintime tfopt --mode evol\n</code></pre> <p>or</p> <pre><code>python -m phoskintime tfopt --mode local\n</code></pre> <p>Output will be saved in structured folders, including Excel files, plots, and an aggregated HTML report.</p>"},{"location":"Documentation/utils/","title":"Utils","text":"<p>The utils module provides a collection of helper functions that streamline data handling, output formatting, file management, and report/table generation throughout the PhosKinTime package. These utilities ensure that results from parameter estimation, sensitivity analysis, and other computations are organized, saved, and displayed consistently.</p>"},{"location":"Documentation/utils/#module-structure","title":"Module Structure","text":"<p>The utils module is organized into the following components:</p>"},{"location":"Documentation/utils/#1-display-utilities-displaypy","title":"1. Display Utilities (<code>display.py</code>)","text":"<p>This submodule includes functions for:</p> <ul> <li>Directory Management: </li> <li> <p><code>ensure_output_directory(directory)</code>: Creates the specified directory if it does not exist.</p> </li> <li> <p>Data Loading: </p> </li> <li> <p><code>load_data(excel_file, sheet=\"Estimated Values\")</code>: Loads and returns data from an Excel file.</p> </li> <li> <p>Formatting: </p> </li> <li> <p><code>format_duration(seconds)</code>: Converts a duration in seconds to a human-readable format (seconds, minutes, or hours).</p> </li> <li> <p>Result Saving: </p> </li> <li> <p><code>save_result(results, excel_filename)</code>: Saves a list of result dictionaries to an Excel file with separate sheets for each gene\u2019s parameters, profiles, and error summaries.</p> </li> <li> <p>Report Generation: </p> </li> <li> <p><code>create_report(results_dir, output_file=\"report.html\")</code>: Generates a global HTML report by aggregating plots and data tables from gene-specific result folders.</p> </li> <li> <p>File Organization: </p> </li> <li><code>organize_output_files(*directories)</code>: Organizes output files by moving gene-specific files into subfolders and grouping remaining files into a \"General\" folder.</li> </ul>"},{"location":"Documentation/utils/#2-table-utilities-tablespy","title":"2. Table Utilities (<code>tables.py</code>)","text":"<p>This submodule provides functions for generating and saving data tables:</p> <ul> <li>Table Generation: </li> <li> <p><code>generate_tables(xlsx_file_path)</code>: Loads alpha and beta values from an Excel file, pivots the data, and creates hierarchical tables combining both sets of values.</p> </li> <li> <p>Table Saving: </p> </li> <li> <p><code>save_tables(tables, output_dir)</code>: Saves each generated hierarchical table as both a LaTeX file and a CSV file, using a naming convention based on protein and phosphorylation site.</p> </li> <li> <p>Master Table Creation: </p> </li> <li><code>save_master_table(folder=\"latex\", output_file=\"latex/all_tables.tex\")</code>: Generates a master LaTeX file that includes all the individual table files from a specified folder.</li> </ul>"}]}